<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kronborg's Ultimate Pok√©mon Checker v3.0</title>
  <style>
    /* Tailwind-like utility classes adapted for TRON theme */
    .bg-black { background-color: #000000; }
    .bg-dark-blue { background-color: #001122; }
    .text-neon-cyan { color: #00ffff; }
    .text-neon-red { color: #ff0040; }
    .text-neon-green { color: #00ff41; }
    .text-white-glow { color: #ffffff; text-shadow: 0 0 5px #00ffff; }
    .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
    .text-2xl { font-size: 1.5rem; line-height: 2rem; }
    .font-bold { font-weight: 700; }
    .font-semibold { font-weight: 600; }
    .p-6 { padding: 1.5rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .w-full { width: 100%; }
    .max-w-md { max-width: 28rem; }
    .rounded { border-radius: 0.25rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .shadow-neon { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.1); }
    .border-neon { border: 1px solid #00ffff; }
    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .min-h-screen { min-height: 100vh; }
    .text-center { text-align: center; }
    .hidden { display: none; }
    
    /* TRON Theme Styles */
    body {
      font-family: 'Orbitron', monospace;
      background: radial-gradient(ellipse at center, #001122 0%, #000011 50%, #000000 100%);
      color: #00ffff;
      position: relative;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #00ffff #001122;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(-45deg, rgba(0,255,255,0.05) 25%, transparent 25%),
        linear-gradient(45deg, rgba(0,255,255,0.05) 25%, transparent 25%),
        linear-gradient(-45deg, transparent 75%, rgba(0,255,255,0.05) 75%),
        linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.05) 75%);
      background-size: 20px 20px;
      z-index: -1;
      animation: gridMove 20s linear infinite;
    }
    @keyframes gridMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(20px, 20px); }
    }
    .tron-card {
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      border-radius: 15px;
      padding: 1.5rem;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.05);
      position: relative;
      z-index: 20;
      animation: pulseGlow 3s ease-in-out infinite alternate;
    }
    @keyframes pulseGlow {
      0% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.1); }
      100% { box-shadow: 0 0 40px rgba(0, 255, 255, 0.8), inset 0 0 20px rgba(0, 255, 255, 0.2); }
    }
    input[type="email"], input[type="url"] {
      border: 2px solid #00ffff;
      background: rgba(0, 0, 0, 0.6);
      color: #00ffff;
      padding: 0.6rem 1rem;
      border-radius: 5px;
      transition: all 0.3s ease;
    }
    input[type="email"]:focus, input[type="url"]:focus {
      border-color: #33ffff;
      outline: none;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    }
    input[readonly] {
      background-color: rgba(0, 17, 34, 0.8);
      cursor: not-allowed;
      color: #66ffff;
    }
    button {
      font-weight: 600;
      transition: all 0.3s ease;
      border: 1px solid #00ffff;
      background: transparent;
      color: #00ffff;
      cursor: pointer;
    }
    button:hover {
      color: #33ffff;
      border-color: #33ffff;
      transform: translateY(-2px);
    }
    .input-group {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      animation: fadeIn 0.5s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .input-group input {
      flex-grow: 1;
      margin-right: 0.5rem;
    }
    .remove-button { color: #ff0040; border-color: #ff0040; padding: 0.5rem 0.75rem; border-radius: 0.25rem; }
    .remove-button:hover { background: rgba(255, 0, 64, 0.1); box-shadow: 0 0 10px rgba(255, 0, 64, 0.5); }
    .submit-button { color: #00ff41; border-color: #00ff41; padding: 0.5rem 0.75rem; border-radius: 0.25rem; }
    .submit-button:hover { background: rgba(0, 255, 65, 0.1); box-shadow: 0 0 10px rgba(0, 255, 65, 0.5); }
    
    .add-email-button {
      background: linear-gradient(45deg, rgba(0, 255, 65, 0.2), rgba(0, 255, 255, 0.2));
      color: #00ff41;
      border: 2px solid #00ff41;
      padding: 0.75rem 1rem;
      border-radius: 15px;
      width: 100%;
      margin-bottom: 0.5rem;
    }
    .add-email-button:hover { box-shadow: 0 0 25px rgba(0, 255, 65, 0.8); }

    .pokezonan-button {
      background: linear-gradient(45deg, rgba(255, 0, 64, 0.3), rgba(0, 255, 255, 0.2));
      color: #ff0040;
      border: 2px solid #ff0040;
      padding: 0.5rem 1rem;
      border-radius: 10px;
      margin-left: 0.5rem;
    }
    .pokezonan-button:hover { box-shadow: 0 0 20px rgba(255, 0, 64, 0.8); }

    .toggle-button { padding: 0.75rem; border-radius: 10px; width: 100%; margin-top: 0.5rem; }
    .toggle-button.active { background: rgba(0, 255, 65, 0.2); color: #00ff41; border-color: #00ff41; }
    .toggle-button.inactive { color: #666666; border-color: #666666; }

    .start-button, .stop-button, .test-button { padding: 0.75rem; border-radius: 10px; width: 100%; margin-top: 0.5rem; }
    .start-button { color: #00ffff; border-color: #00ffff; }
    .start-button:hover { background: rgba(0, 255, 255, 0.2); box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
    .stop-button { color: #ff0040; border-color: #ff0040; }
    .stop-button:hover { background: rgba(255, 0, 64, 0.2); box-shadow: 0 0 20px rgba(255, 0, 64, 0.8); }
    .test-button { color: #00ff41; border-color: #00ff41; }
    .test-button:hover { background: rgba(0, 255, 65, 0.2); box-shadow: 0 0 20px rgba(0, 255, 65, 0.8); }

    input[type="range"] { -webkit-appearance: none; width: 100%; height: 8px; background: rgba(0, 255, 255, 0.2); border-radius: 5px; outline: none; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #00ffff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(0, 255, 255, 0.8); }

    .status-feedback { color: #00ff41; font-size: 0.875rem; margin-top: 0.5rem; text-align: center; opacity: 0; transition: opacity 0.5s ease; text-shadow: 0 0 5px #00ff41; }
    .status-feedback.show { opacity: 1; }
    .status-neon-green { color: #00ff41; text-shadow: 0 0 10px #00ff41; }
    .status-neon-red { color: #ff0040; text-shadow: 0 0 10px #ff0040; }
    .status-neon-yellow { color: #ffff00; text-shadow: 0 0 10px #ffff00; }

    h1 { color: #00ffff; text-shadow: 0 0 15px #00ffff; font-weight: 900; letter-spacing: 2px; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body class="bg-black flex items-center justify-center min-h-screen">
  <div class="tron-card p-6 rounded-lg shadow-neon w-full max-w-md">
    <h1 class="text-2xl font-bold text-center mb-2">Kronborg's Ultimate Pok√©mon Checker v3.0</h1>
    <p class="text-gray-600 text-center mb-2 text-sm">Enhanced Pokemon Center Queue & ETB Detector</p>

    <div id="emailInputsContainer" class="mb-2">
      <label class="block text-sm text-neon-cyan mb-1">Emails for alerts:</label>
      <div class="input-group">
        <input type="email" placeholder="name@example.com" class="w-full border-neon rounded px-3 py-2 email-input" required>
        <button type="button" class="submit-button email-submit-button">Submit</button>
      </div>
    </div>
    <button id="addEmailButton" class="add-email-button">Catch Another Email! ‚ú®</button>

    <div id="discordWebhookContainer" class="mb-2">
      <label class="block text-sm text-neon-cyan mb-1">Discord Webhook URL:</label>
      <div class="input-group">
        <input
          type="url"
          id="webhookUrlInput"
          placeholder="https://discord.com/api/webhooks/..."
          class="w-full border-neon rounded px-3 py-2"
          required
        >
        <button type="button" id="submitWebhookButton" class="submit-button">Add Webhook</button>
        <button id="addPokezonanButton" class="pokezonan-button" type="button">Add Pokezonan</button>
      </div>
    </div>

    <div id="emailFeedback" class="status-feedback"></div>

    <div class="mb-2">
      <label for="frequencySlider" class="block text-sm text-neon-cyan mb-1">
        Check every: <span id="frequencyValue" class="font-semibold text-white-glow">10</span> minutes
      </label>
      <input type="range" id="frequencySlider" min="1" max="60" value="10">
    </div>

    <div id="status" class="text-center mb-2">
      <p class="text-lg">Status: <span id="statusText" class="font-semibold status-neon-red">Waiting...</span></p>
      <p class="text-sm text-neon-cyan">Last checked: <span id="lastChecked">Never</span></p>
      <p class="text-sm text-neon-cyan">System running for: <span id="runTime">0h 0m 0s</span></p>
      <p class="text-sm text-neon-cyan">Details: <span id="statusDetails">None</span></p>
      <p id="warningMsg" class="text-xs text-neon-red hidden mt-1">‚ö†Ô∏è Keep tab active for best reliability!</p>
    </div>

    <button id="startButton" class="start-button">Start Checking</button>
    <button id="stopButton" class="stop-button hidden">Stop Checking</button>
    <button id="emailToggleButton" class="toggle-button active">Deactivate Email Alerts</button>
    <button id="discordToggleButton" class="toggle-button active">Deactivate Discord Alerts</button>
    <button id="testEmailButton" class="test-button">Test Alerts</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4.4.1/dist/email.min.js"></script>
  <script>
    // --- AUDIO ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playBeep() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'square';
        oscillator.frequency.value = 880; // A5
        gainNode.gain.value = 0.1;
        oscillator.start();
        setTimeout(() => { oscillator.stop(); }, 200);
    }
    function playThreeBeeps() {
        playBeep();
        setTimeout(playBeep, 400);
        setTimeout(playBeep, 800);
    }

    if (typeof emailjs === 'undefined') {
      console.error('EmailJS failed to load.');
      alert('Email functionality is unavailable.');
    } else {
      emailjs.init({ publicKey: "8w7eu6mrg3lRl6ta3" });
    }

    // --- DOM Selectors ---
    const statusText = document.getElementById('statusText');
    const lastChecked = document.getElementById('lastChecked');
    const statusDetails = document.getElementById('statusDetails');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const testEmailButton = document.getElementById('testEmailButton');
    const emailToggleButton = document.getElementById('emailToggleButton');
    const discordToggleButton = document.getElementById('discordToggleButton');
    const webhookUrlInput = document.getElementById('webhookUrlInput');
    const submitWebhookButton = document.getElementById('submitWebhookButton');
    const addPokezonanButton = document.getElementById('addPokezonanButton');
    const runTime = document.getElementById('runTime');
    const emailInputsContainer = document.getElementById('emailInputsContainer');
    const addEmailButton = document.getElementById('addEmailButton');
    const emailFeedback = document.getElementById('emailFeedback');
    const frequencySlider = document.getElementById('frequencySlider');
    const frequencyValue = document.getElementById('frequencyValue');
    const warningMsg = document.getElementById('warningMsg');

    // --- Global Variables ---
    let intervalId = null;
    let startTime = null;
    let timerInterval = null;
    let currentCheckInterval = 10 * 60 * 1000;
    let emailNotificationsEnabled = true;
    let discordNotificationsEnabled = true;
    let discordWebhookUrl = null;

    // --- Utility Functions ---
    function showEmailFeedback(message) {
      emailFeedback.textContent = message;
      emailFeedback.classList.add('show');
      setTimeout(() => emailFeedback.classList.remove('show'), 2000);
    }

    function getRandomInterval(baseInterval) {
      const variation = Math.floor(Math.random() * 30000) + 30000; // 30-60 seconds variation
      return baseInterval + variation;
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      return `${hours}h ${minutes}m ${secs}s`;
    }

    function updateRunTime() {
      if (startTime) {
        const now = Date.now();
        runTime.textContent = formatDuration(now - startTime);
      }
    }

    function startTimer() {
      if (!startTime) {
        startTime = Date.now();
        timerInterval = setInterval(updateRunTime, 1000);
      }
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      startTime = null;
      runTime.textContent = '0h 0m 0s';
    }

    // Enhanced queue detection
    function detectQueueStatus(text, url) {
      // Comprehensive queue detection patterns
      const queueIndicators = [
        // Queue-it specific patterns
        { pattern: /queue-it/i, weight: 10 },
        { pattern: /queue\.it/i, weight: 10 },
        { pattern: /waiting[\s\S]*?room/i, weight: 9 },
        { pattern: /you[\s\S]*?are[\s\S]*?in[\s\S]*?line/i, weight: 8 },
        { pattern: /estimated[\s\S]*?wait/i, weight: 8 },
        { pattern: /users[\s\S]*?ahead/i, weight: 7 },
        { pattern: /queue[\s\S]*?position/i, weight: 7 },
        { pattern: /please[\s\S]*?wait/i, weight: 6 },
        { pattern: /virtual[\s\S]*?waiting/i, weight: 6 },
        { pattern: /hold[\s\S]*?tight/i, weight: 5 },
        { pattern: /stay[\s\S]*?patient/i, weight: 5 },
        { pattern: /redirecting[\s\S]*?queue/i, weight: 5 },
        // URL patterns
        { pattern: /\/queue\//i, weight: 8 },
        { pattern: /\?queue/i, weight: 7 },
        // Script patterns
        { pattern: /queue.*\.js/i, weight: 6 },
        { pattern: /waiting.*\.js/i, weight: 6 }
      ];

      // Blocked/Challenge patterns
      const blockedIndicators = [
        { pattern: /cloudflare/i, weight: 10 },
        { pattern: /access[\s\S]*?denied/i, weight: 9 },
        { pattern: /just[\s\S]*?moment/i, weight: 9 },
        { pattern: /captcha/i, weight: 8 },
        { pattern: /challenge/i, weight: 8 },
        { pattern: /security[\s\S]*?check/i, weight: 7 },
        { pattern: /distil/i, weight: 7 },
        { pattern: /incapsula/i, weight: 7 },
        { pattern: /blocked/i, weight: 6 },
        { pattern: /forbidden/i, weight: 6 }
      ];

      // Shop accessible patterns
      const shopIndicators = [
        { pattern: /pok√©mon[\s\S]*?center/i, weight: 10 },
        { pattern: /pokemon[\s\S]*?center/i, weight: 10 },
        { pattern: /sign[\s\S]*?in/i, weight: 8 },
        { pattern: /my[\s\S]*?cart/i, weight: 8 },
        { pattern: /add[\s\S]*?to[\s\S]*?cart/i, weight: 8 },
        { pattern: /product[\s\S]*?grid/i, weight: 7 },
        { pattern: /trading[\s\S]*?card[\s\S]*?game/i, weight: 9 },
        { pattern: /elite[\s\S]*?trainer[\s\S]*?box/i, weight: 9 },
        { pattern: /etb/i, weight: 8 },
        { pattern: /plush/i, weight: 7 },
        { pattern: /figures/i, weight: 7 },
        { pattern: /apparel/i, weight: 6 },
        { pattern: /shop[\s\S]*?now/i, weight: 6 },
        { pattern: /buy[\s\S]*?now/i, weight: 6 }
      ];

      // Calculate scores
      let queueScore = 0;
      let blockedScore = 0;
      let shopScore = 0;

      queueIndicators.forEach(indicator => {
        if (indicator.pattern.test(text) || indicator.pattern.test(url)) {
          queueScore += indicator.weight;
        }
      });

      blockedIndicators.forEach(indicator => {
        if (indicator.pattern.test(text)) {
          blockedScore += indicator.weight;
        }
      });

      shopIndicators.forEach(indicator => {
        if (indicator.pattern.test(text)) {
          shopScore += indicator.weight;
        }
      });

      // Extract queue position if possible
      let queuePosition = null;
      const positionMatches = [
        text.match(/(\d+,?\d*)\s*(users? ahead|people ahead|ahead of you|in line)/i),
        text.match(/position\s*[#:]?\s*(\d+,?\d*)/i),
        text.match(/waiting:\s*(\d+,?\d*)/i),
        text.match(/queue\s*[#:]?\s*(\d+,?\d*)/i),
        text.match(/(\d+)\s*(?:more)?\s*users?/i)
      ];
      
      for (const match of positionMatches) {
        if (match && match[1]) {
          queuePosition = match[1];
          break;
        }
      }

      // Special ETB detection
      const hasETB = /elite trainer box/i.test(text) || /etb/i.test(text);
      const hasTemporalForces = /temporal[\s\S]*?forces/i.test(text);
      const has151 = /151|scarlet.*violet|paldea.*evolved/i.test(text);

      return {
        queueScore,
        blockedScore,
        shopScore,
        queuePosition,
        hasETB,
        hasTemporalForces,
        has151,
        textLength: text.length
      };
    }

    // --- Notification Functions ---
    async function sendDiscordMessage(status, details, isETB = false) {
      if (!discordNotificationsEnabled || !discordWebhookUrl) return;
      
      const isAccessible = status.includes('Accessible');
      const isQueue = status.includes('Queue');
      const isETBAlert = isETB || details.includes('ETB') || details.includes('Elite Trainer Box');
      
      let color, title, thumbnail;
      
      if (isETBAlert) {
        color = 16776960; // Yellow for ETB alerts
        title = 'üî• POK√âMON ETB AVAILABLE! üöÄ';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/384.png'; // Rayquaza
      } else if (isAccessible) {
        color = 3066993; // Green
        title = '‚úÖ SHOP ACCESSIBLE';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png'; // Pikachu
      } else if (isQueue) {
        color = 15158332; // Red
        title = '‚ö†Ô∏è QUEUE ACTIVE';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/143.png'; // Snorlax
      } else {
        color = 10181046; // Purple
        title = 'üö® STATUS ALERT';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png'; // Ditto
      }
      
      const payload = {
        embeds: [{
          title: title,
          description: `**Status:** ${status}\n**Details:** ${details}`,
          color: color,
          thumbnail: { url: thumbnail },
          timestamp: new Date().toISOString(),
          footer: { text: 'Kronborg\'s Ultimate Pok√©mon Checker v3.0' }
        }]
      };
      
      try {
        await fetch(discordWebhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
      } catch (error) {
        console.error('Discord Error:', error);
      }
    }

    function sendEmail(status, details, recipientEmails, isETB = false) {
      if (!emailNotificationsEnabled || !recipientEmails.length) return;
      
      let subject = isETB ? 'üö® POK√âMON ETB AVAILABLE! üöÄ' : `Pok√©mon Center Alert: ${status}`;
      let coolDetails = isETB 
        ? `**üî• ULTIMATE ALERT! üî•**\n\n${status}\n\n${details}\n\nüéÆ GET YOUR ELITE TRAINER BOX NOW! üéÆ`
        : `**üö® ALERT! üö®**\n\nStatus: ${status}\n\n${details}`;
      
      recipientEmails.forEach(email => {
        emailjs.send("service_ahqdaj5", "template_whhvnra", {
          status: status,
          details: coolDetails,
          timestamp: new Date().toLocaleString(),
          to_email: email,
          subject: subject
        });
      });
    }

    function testEmail() {
      const inputs = document.querySelectorAll('.email-input');
      const emails = Array.from(inputs).filter(i => i.hasAttribute('readonly')).map(i => i.value);
      
      if (!emails.length && !discordWebhookUrl) {
        alert('Add a valid email or webhook first!');
        return;
      }

      playThreeBeeps();
      
      if(emails.length && emailNotificationsEnabled) {
          sendEmail('üß™ Test Alert', 'System is functioning normally!', emails);
      }
      if(discordWebhookUrl && discordNotificationsEnabled) {
          sendDiscordMessage('üß™ Test Alert', 'System is functioning normally!');
      }
      alert('Test fired! Check your devices.');
    }

    // --- Core Logic ---
    async function checkShopAccess() {
      const emailInputs = document.querySelectorAll('.email-input');
      const currentEmails = Array.from(emailInputs)
        .filter(input => input.hasAttribute('readonly'))
        .map(input => input.value.trim());

      // Use multiple URLs to check
      const urlsToCheck = [
        'https://www.pokemoncenter.com',
        'https://www.pokemoncenter.com/category/trading-card-game',
        'https://www.pokemoncenter.com/products/pokemon-tcg-temporal-forces-elite-trainer-box',
        'https://www.pokemoncenter.com/category/pokemon-trading-card-game'
      ];

      // Rotate through URLs to avoid patterns
      const targetUrl = urlsToCheck[Math.floor(Date.now() / 60000) % urlsToCheck.length];
      const cacheBuster = `?nocache=${Date.now()}&ref=${Math.random().toString(36).substring(7)}`;
      const fullUrl = targetUrl + cacheBuster;

      let response = null;
      let text = '';
      let finalUrl = targetUrl;

      // Try multiple approaches
      const fetchAttempts = [
        // Method 1: Direct fetch with realistic headers
        async () => {
          const headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1'
          };

          // Rotate User-Agent
          const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0'
          ];
          
          headers['User-Agent'] = userAgents[Math.floor(Math.random() * userAgents.length)];

          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            const res = await fetch(fullUrl, {
              method: 'GET',
              headers: headers,
              mode: 'cors',
              credentials: 'omit',
              referrerPolicy: 'strict-origin-when-cross-origin',
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            return res;
          } catch (error) {
            return null;
          }
        },
        
        // Method 2: Use CORS proxies
        async () => {
          const proxies = [
            `https://api.allorigins.win/get?url=${encodeURIComponent(fullUrl)}`,
            `https://corsproxy.io/?${encodeURIComponent(fullUrl)}`,
            `https://proxy.cors.sh/${fullUrl}`,
            `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(fullUrl)}`
          ];
          
          for (const proxy of proxies) {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000);
              
              const res = await fetch(proxy, {
                signal: controller.signal,
                headers: {
                  'Accept': 'application/json,text/html',
                  'Cache-Control': 'no-cache'
                }
              });
              
              clearTimeout(timeoutId);
              
              if (res.ok) {
                if (proxy.includes('allorigins.win')) {
                  const data = await res.json();
                  // Create a mock response object
                  return {
                    ok: true,
                    url: fullUrl,
                    text: async () => data.contents
                  };
                }
                return res;
              }
            } catch (error) {
              continue;
            }
          }
          return null;
        },
        
        // Method 3: Try iframe method
        async () => {
          return new Promise((resolve) => {
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = fullUrl;
            iframe.onload = () => {
              setTimeout(() => {
                try {
                  // Try to get content from iframe
                  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                  if (iframeDoc && iframeDoc.body) {
                    // Create a mock response
                    resolve({
                      ok: true,
                      url: fullUrl,
                      text: async () => iframeDoc.body.innerHTML
                    });
                  } else {
                    resolve(null);
                  }
                } catch (error) {
                  resolve(null);
                } finally {
                  document.body.removeChild(iframe);
                }
              }, 3000);
            };
            iframe.onerror = () => {
              document.body.removeChild(iframe);
              resolve(null);
            };
            document.body.appendChild(iframe);
          });
        }
      ];

      // Try each method until one works
      for (const attempt of fetchAttempts) {
        try {
          response = await attempt();
          if (response && response.ok) {
            text = typeof response.text === 'function' ? await response.text() : response.text;
            finalUrl = response.url || finalUrl;
            break;
          }
        } catch (error) {
          console.log('Fetch attempt failed:', error.message);
          continue;
        }
      }

      const now = new Date().toLocaleTimeString();
      lastChecked.textContent = now;

      if (!text) {
        // Last resort: Check if we can ping the domain
        try {
          await fetch(`https://dns.google/resolve?name=pokemoncenter.com&type=A`, { mode: 'no-cors' });
          statusText.textContent = 'Domain Resolves';
          statusText.className = 'font-semibold status-neon-yellow';
          statusDetails.textContent = 'Cannot fetch content. Likely anti-bot protection.';
          return;
        } catch (dnsError) {
          statusText.textContent = 'Network Error';
          statusText.className = 'font-semibold status-neon-red';
          statusDetails.textContent = 'Cannot reach Pokemon Center. Check internet.';
          return;
        }
      }

      // Analyze the response
      const analysis = detectQueueStatus(text, finalUrl);
      const isSmallResponse = text.length < 5000;
      
      // Determine status based on scores
      let status = '';
      let details = '';
      let shouldAlert = false;
      let isETBAlert = false;
      
      if (analysis.blockedScore > 15) {
        status = 'Bot Blocked';
        details = 'PokemonCenter is blocking access (Cloudflare/anti-bot).';
        shouldAlert = true;
      } else if (analysis.queueScore > 12) {
        status = 'Queue Active';
        details = analysis.queuePosition 
          ? `Waiting in queue. Position: ${analysis.queuePosition}`
          : 'Waiting in queue (position unknown).';
        shouldAlert = true;
      } else if (analysis.shopScore > 15) {
        status = 'Shop Accessible';
        details = 'Pokemon Center shop content detected.';
        
        // Check for ETB specifically
        if (analysis.hasETB) {
          details += ' ELITE TRAINER BOX DETECTED!';
          isETBAlert = true;
          shouldAlert = true;
        } else {
          // Don't alert for normal shop access to avoid spam
          shouldAlert = false;
        }
      } else if (isSmallResponse) {
        status = 'Challenge Page';
        details = `Response too small (${text.length} chars). Likely CAPTCHA or challenge.`;
      } else {
        status = 'Unknown Content';
        details = `Got response (${text.length} chars) but cannot determine status.`;
      }
      
      // Update display
      statusText.textContent = status;
      statusDetails.textContent = details;
      
      // Set color based on status
      if (status.includes('Accessible')) {
        statusText.className = 'font-semibold status-neon-green';
      } else if (status.includes('Queue') || status.includes('Blocked')) {
        statusText.className = 'font-semibold status-neon-red';
      } else if (status.includes('Challenge')) {
        statusText.className = 'font-semibold status-neon-yellow';
      } else {
        statusText.className = 'font-semibold text-white-glow';
      }
      
      // Check if we should send alerts
      const prevStatus = statusText.dataset.previousStatus;
      statusText.dataset.previousStatus = status;
      
      if (shouldAlert && prevStatus !== status) {
        playThreeBeeps();
        
        // Special handling for ETB alerts
        if (isETBAlert) {
          sendEmail(`üö® ETB AVAILABLE: ${status}`, details, currentEmails, true);
          sendDiscordMessage(status, details, true);
        } else {
          sendEmail(status, details, currentEmails);
          sendDiscordMessage(status, details);
        }
      }
    }

    function startChecking() {
      const emails = document.querySelectorAll('.email-input[readonly]').length;
      const webhook = webhookUrlInput.hasAttribute('readonly');
      
      if (!emails && !webhook) {
        alert('Please add an Email or Webhook first!');
        return;
      }

      if (intervalId) clearTimeout(intervalId);
      
      function scheduleNext() {
        const mins = parseInt(frequencySlider.value);
        const base = mins * 60000;
        const nextDelay = getRandomInterval(base);
        
        intervalId = setTimeout(() => {
            checkShopAccess();
            scheduleNext();
        }, nextDelay);
      }

      checkShopAccess();
      scheduleNext();

      startButton.classList.add('hidden');
      stopButton.classList.remove('hidden');
      statusText.textContent = 'Active';
      startTimer();
    }
    
    function stopChecking() {
      if (intervalId) clearTimeout(intervalId);
      stopTimer();
      startButton.classList.remove('hidden');
      stopButton.classList.add('hidden');
      statusText.textContent = 'Stopped';
    }

    // --- Event Listeners ---
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) warningMsg.classList.remove('hidden');
        else warningMsg.classList.add('hidden');
    });

    emailToggleButton.addEventListener('click', () => {
      emailNotificationsEnabled = !emailNotificationsEnabled;
      emailToggleButton.classList.toggle('active');
      emailToggleButton.classList.toggle('inactive');
      emailToggleButton.textContent = emailNotificationsEnabled ? 'Deactivate Email Alerts' : 'Activate Email Alerts';
    });

    discordToggleButton.addEventListener('click', () => {
      discordNotificationsEnabled = !discordNotificationsEnabled;
      discordToggleButton.classList.toggle('active');
      discordToggleButton.classList.toggle('inactive');
      discordToggleButton.textContent = discordNotificationsEnabled ? 'Deactivate Discord Alerts' : 'Activate Discord Alerts';
    });

    submitWebhookButton.addEventListener('click', () => {
      if (webhookUrlInput.hasAttribute('readonly')) {
          webhookUrlInput.removeAttribute('readonly');
          webhookUrlInput.value = '';
          discordWebhookUrl = null;
          submitWebhookButton.textContent = 'Add Webhook';
          submitWebhookButton.classList.replace('remove-button', 'submit-button');
      } else {
          if(!webhookUrlInput.value.includes('discord.com/api/webhooks')) {
              alert('Invalid Webhook URL'); return;
          }
          webhookUrlInput.setAttribute('readonly', true);
          discordWebhookUrl = webhookUrlInput.value;
          submitWebhookButton.textContent = 'Remove';
          submitWebhookButton.classList.replace('submit-button', 'remove-button');
      }
    });

    // --- POKEZONAN BUTTON LOGIC ---
    addPokezonanButton.addEventListener('click', () => {
        const pokezonanUrl = "https://discord.com/api/webhooks/1418654823745716436/vuMKu1s095Cq3BfU06OF_Z_mwxG39zHppHJ3c4BX5X38WuJFWPGhIZdopWTEEXlophiN";
        
        discordWebhookUrl = pokezonanUrl;
        webhookUrlInput.value = "Pokezonan Webhook Loaded üîí";
        webhookUrlInput.setAttribute('readonly', true);
        submitWebhookButton.textContent = 'Remove';
        submitWebhookButton.classList.replace('submit-button', 'remove-button');
        showEmailFeedback('Pokezonan Webhook Connected! üéÆ');
    });

    // Email management
    function setupEmailButton(btn) {
        btn.addEventListener('click', (e) => {
            const input = e.target.previousElementSibling;
            if(input.value.includes('@')) {
                input.setAttribute('readonly', true);
                e.target.textContent = 'Remove';
                e.target.className = 'remove-button';
                e.target.onclick = () => e.target.parentElement.remove();
                showEmailFeedback('Email Added! ‚úâÔ∏è');
            } else {
                alert('Invalid Email');
            }
        });
    }

    addEmailButton.addEventListener('click', () => {
        const div = document.createElement('div');
        div.className = 'input-group';
        div.innerHTML = `<input type="email" placeholder="name@example.com" class="w-full border-neon rounded px-3 py-2 email-input"><button type="button" class="submit-button email-submit-button">Submit</button>`;
        emailInputsContainer.appendChild(div);
        setupEmailButton(div.querySelector('button'));
    });
    
    // Initialize first email button
    setupEmailButton(document.querySelector('.email-submit-button'));

    frequencySlider.addEventListener('input', function() {
      frequencyValue.textContent = this.value;
      currentCheckInterval = this.value * 60 * 1000;
    });

    startButton.addEventListener('click', startChecking);
    stopButton.addEventListener('click', stopChecking);
    testEmailButton.addEventListener('click', testEmail);
    
    // Initialize status data attribute
    statusText.dataset.previousStatus = '';
  </script>
</body>
</html>
