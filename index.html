<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PokÃ©mon Center Shop Access Monitor</title>
  <style>
    /* Professional Tron-like Theme & Utility Classes */
    .bg-blue-500 { background-color: #3b82f6; } .bg-red-500 { background-color: #ef4444; }
    .bg-green-500 { background-color: #10b981; } .bg-purple-500 { background-color: #8b5cf6; }
    .bg-gray-500 { background-color: #6b7280; } .bg-yellow-500 { background-color: #f59e0b; }
    .text-black { color: #000; } .text-white { color: #fff; } .text-red-500 { color: #ef4444; }
    .text-green-500 { color: #22c55e; } .text-orange-500 { color: #f97316; }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; } .font-bold { font-weight: 700; }
    .font-semibold { font-weight: 600; } .mt-1 { margin-top: 0.25rem; } .mt-2 { margin-top: 0.5rem; }
    .w-full { width: 100%; } .hidden { display: none; }

    body {
        font-family: 'Nunito', sans-serif;
        background: linear-gradient(to bottom, #0a0a0a, #1a1a2e, #16213e, #0f3460);
        color: #ffffff;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
    }
    .main-container {
        background: rgba(10, 10, 10, 0.9);
        border: 2px solid #00ffff;
        box-shadow: 0 0 20px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.1);
        border-radius: 10px;
        padding: 2rem;
        width: 100%;
        max-width: 42rem;
        display: flex;
        flex-direction: column;
    }
    .header {
        display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem;
        padding: 1rem; background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff;
        border-radius: 8px; box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }
    .header h1 {
        font-size: 1.25rem; font-weight: bold; color: #00ffff;
        text-shadow: 0 0 10px #00ffff; margin: 0; flex: 1; text-align: center;
    }
    .pokemon-header-sprite { width: 72px; height: auto; filter: drop-shadow(0 0 10px #00ffff); }
    .magikarp-header { animation: bob 2s infinite ease-in-out; }
    .cubone-header { animation: hop 3s infinite ease-in-out; }
    @keyframes bob { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    @keyframes hop { 0%, 100% { transform: translateY(0) rotate(0deg); } 50% { transform: translateY(-15px) rotate(5deg); } }
    .section {
        margin-bottom: 1.5rem; padding: 1rem; background: rgba(26, 26, 46, 0.5);
        border: 1px solid #00ffff; border-radius: 8px; box-shadow: 0 0 5px rgba(0, 255, 255, 0.2);
    }
    .section label { display: block; font-size: 0.875rem; font-weight: 600; color: #00ffff; margin-bottom: 0.5rem; }
    input[type="email"], input[type="url"], input[type="range"] {
        width: 100%; padding: 0.75rem; border: 1px solid #00ffff; border-radius: 4px;
        background: rgba(10, 10, 10, 0.8); color: #ffffff;
        box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); transition: box-shadow 0.3s ease;
    }
    input[type="email"]:focus, input[type="url"]:focus { outline: none; box-shadow: 0 0 10px #00ffff; }
    .input-group { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
    .input-group input { flex: 1; }
    .input-group button { flex-shrink: 0; width: auto; padding: 0.5rem 1rem; }
    .submitted-list ul { list-style: none; padding: 0; margin-top: 0.5rem; }
    .submitted-list li {
        display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem;
        background: rgba(107, 114, 128, 0.5); border: 1px solid #00ffff; border-radius: 4px;
        box-shadow: 0 0 5px rgba(0, 255, 255, 0.2); word-break: break-all;
    }
    .submitted-list li span { flex: 1; font-size: 0.875rem; color: #b0b0b0; }
    .submitted-list li button { flex-shrink: 0; width: auto; padding: 0.5rem 1rem; font-size: 0.875rem; }
    button {
        width: 100%; padding: 0.75rem; border: none; border-radius: 4px; color: #000; font-weight: 600;
        cursor: pointer; box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        transition: all 0.3s ease; white-space: normal; text-align: center;
    }
    button:hover { box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); transform: translateY(-2px); }
    button.active { background: linear-gradient(45deg, #10b981, #059669); }
    button.inactive { background: #6b7280; }
    .button-group { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem; margin-bottom: 1.5rem; }
    .status-display { padding: 1rem; }
    .status-display p { margin: 0.25rem 0; }
    .live-log {
        height: 200px; overflow-y: scroll; background: rgba(10, 10, 10, 0.8); border: 1px solid #00ffff;
        border-radius: 8px; padding: 1rem; margin-top: 1rem; font-size: 0.75rem; font-family: 'Courier New', monospace;
        box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
    }
    .live-log p { margin: 0.25rem 0; word-wrap: break-word; color: #ffffff; }
    .status-feedback {
        color: #00ff00; font-size: 0.875rem; text-align: center; height: 1.25rem;
        opacity: 0; transition: opacity 0.5s ease;
    }
    .status-feedback.show { opacity: 1; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<div class="main-container">
    <div class="header">
        <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/129.png" alt="Magikarp" class="pokemon-header-sprite magikarp-header">
        <h1>PokÃ©mon Center Shop Access Checker</h1>
        <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/104.png" alt="Cubone" class="pokemon-header-sprite cubone-header">
    </div>

    <div class="section">
        <label>Emails for Alerts (add one by one):</label>
        <div class="input-group">
            <input type="email" id="emailInput" placeholder="name@example.com" required>
            <button type="button" id="addEmailButton" class="bg-green-500 text-white">Add Email</button>
        </div>
        <div class="submitted-list"><ul id="emailList"></ul></div>
    </div>

    <div class="section">
        <label>Discord Webhook (add one by one):</label>
        <div class="input-group">
            <input type="url" id="webhookInput" placeholder="https://discord.com/api/webhooks/..." required>
            <button type="button" id="addWebhookButton" class="bg-purple-500 text-white">Add Webhook</button>
        </div>
        <div class="submitted-list"><ul id="webhookList"></ul></div>
    </div>
    
    <div class="section">
        <label>Check every: <span id="frequencyValue" class="font-semibold">10</span> minutes</label>
        <input type="range" id="frequencySlider" min="1" max="60" value="10">
    </div>

    <div class="button-group">
        <button id="startButton" class="bg-blue-500 text-white">Start Checking</button>
        <button id="stopButton" class="bg-red-500 text-white hidden">Stop Checking</button>
        <button id="testButton" class="bg-yellow-500 text-black">Test Single Check</button>
        <button id="emailToggleButton" class="active bg-green-500 text-white">Deactivate Email Alerts</button>
        <button id="webhookToggleButton" class="active bg-green-500 text-white">Deactivate Discord Alerts</button>
        <button id="testAlertsButton" class="bg-purple-500 text-white">Test All Alerts</button>
    </div>

    <div class="section status-display">
        <p><strong>Status:</strong> <span id="statusText" class="font-semibold">Waiting...</span></p>
        <p><strong>Last checked:</strong> <span id="lastChecked">Never</span></p>
        <p><strong>Running for:</strong> <span id="runTime">0h 0m 0s</span></p>
        <p><strong>Details:</strong> <span id="statusDetails">System not started.</span></p>
    </div>
    
    <div id="statusFeedback" class="status-feedback"></div>
    <div id="liveLog" class="live-log">
        <p>[SYSTEM] PokÃ©mon Center Shop Access Checker initialized! ðŸš€</p>
    </div>
</div>

<audio id="beepSound">
    <source src="https://www.soundjay.com/buttons/beep-01a.mp3" type="audio/mpeg">
</audio>

<script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4.4.1/dist/email.min.js"></script>
<script>
    // --- INITIALIZATION & CONFIGURATION ---
    emailjs.init({ publicKey: "8w7eu6mrg3lRl6ta3" });

    const CONFIG = {
        TARGET_URLS: [
            'https://www.pokemoncenter.com/',
            'https://www.pokemoncenter.com/category/trading-card-game',
            'https://www.pokemoncenter.com/category/new-releases'
        ],
        PROXIES: [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
        ],
        USER_AGENT: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36',
    };
    
    // IMPORTANT: Replace with your actual CapSolver API key
    const CAPSOLVER_API_KEY = 'CAP-E20E90A1238FE858B9CCCFC6F53DC436C385BF7089101FD86F5EEA47FC43CA95';

    const STATUS_TYPE = Object.freeze({
        AVAILABLE: 'AVAILABLE', IN_QUEUE: 'IN_QUEUE', BOT_PROTECTION: 'BOT_PROTECTION',
        CAPTCHA: 'CAPTCHA', FETCH_ERROR: 'FETCH_ERROR', MINIMAL_CONTENT: 'MINIMAL_CONTENT',
        UNEXPECTED_REDIRECT: 'UNEXPECTED_REDIRECT', CRITICAL_ERROR: 'CRITICAL_ERROR', WAITING: 'WAITING'
    });

    const SHOP_AVAILABLE_KEYWORDS = ["pokÃ©mon center official site", "<link rel=\"icon\"", "the pokÃ©mon company international", "</html>"];
    const MIN_PROXY_RESPONSE_SIZE = 1500;

    // --- DOM ELEMENT SELECTORS ---
    const dom = {
        statusText: document.getElementById('statusText'),
        lastChecked: document.getElementById('lastChecked'),
        statusDetails: document.getElementById('statusDetails'),
        runTime: document.getElementById('runTime'),
        liveLog: document.getElementById('liveLog'),
        startButton: document.getElementById('startButton'),
        stopButton: document.getElementById('stopButton'),
        testButton: document.getElementById('testButton'),
        emailInput: document.getElementById('emailInput'),
        addEmailButton: document.getElementById('addEmailButton'),
        emailList: document.getElementById('emailList'),
        webhookInput: document.getElementById('webhookInput'),
        addWebhookButton: document.getElementById('addWebhookButton'),
        webhookList: document.getElementById('webhookList'),
        frequencySlider: document.getElementById('frequencySlider'),
        frequencyValue: document.getElementById('frequencyValue'),
        statusFeedback: document.getElementById('statusFeedback'),
        emailToggleButton: document.getElementById('emailToggleButton'),
        webhookToggleButton: document.getElementById('webhookToggleButton'),
        testAlertsButton: document.getElementById('testAlertsButton'),
        beepSound: document.getElementById('beepSound'),
    };

    // --- GLOBAL STATE ---
    let state = {
        intervalId: null,
        startTime: null,
        timerInterval: null,
        currentStatus: STATUS_TYPE.WAITING,
        statusDetails: 'System not started.',
        previousStatus: 'NONE',
        recipientEmails: [],
        discordWebhooks: [],
        emailNotificationsEnabled: true,
        discordNotificationsEnabled: true,
    };

    // --- UTILITY & LOGGING ---
    const log = (message) => {
        const timestamp = new Date().toLocaleTimeString();
        const p = document.createElement('p');
        p.textContent = `[${timestamp}] ${message}`;
        dom.liveLog.prepend(p);
        console.log(message);
    };

    const showFeedback = (message, isError = false) => {
        dom.statusFeedback.textContent = message;
        dom.statusFeedback.style.color = isError ? '#ef4444' : '#22c55e';
        dom.statusFeedback.classList.add('show');
        setTimeout(() => dom.statusFeedback.classList.remove('show'), 3000);
    };

    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const formatDuration = (ms) => {
        if (ms <= 0) return '0h 0m 0s';
        const s = Math.floor(ms / 1000);
        return `${Math.floor(s/3600)}h ${Math.floor((s%3600)/60)}m ${s%60}s`;
    };
    
    const playBeep = () => dom.beepSound.play().catch(e => log('Audio playback blocked by browser.'));

    // --- CORE LOGIC ---
    const getStatusDisplay = (statusType) => {
        switch (statusType) {
            case STATUS_TYPE.AVAILABLE: return { text: 'ðŸŸ¢ Shop Available!', color: 0x00FF00 };
            case STATUS_TYPE.IN_QUEUE: return { text: 'ðŸŸ  In Queue', color: 0xFFA500 };
            case STATUS_TYPE.BOT_PROTECTION: return { text: 'ðŸ”’ Bot Protection', color: 0xFFA500 };
            case STATUS_TYPE.CAPTCHA: return { text: 'ðŸ¤” CAPTCHA Detected', color: 0xFFA500 };
            case STATUS_TYPE.MINIMAL_CONTENT: return { text: 'ðŸš¨ Unrecognized Content', color: 0xFF0000 };
            case STATUS_TYPE.UNEXPECTED_REDIRECT: return { text: 'â†ªï¸ Unexpected Redirect', color: 0xFF0000 };
            case STATUS_TYPE.FETCH_ERROR: return { text: 'âŒ Proxy/Fetch Error', color: 0xFF0000 };
            case STATUS_TYPE.CRITICAL_ERROR: return { text: 'ðŸ’¥ Critical Error', color: 0xFF0000 };
            default: return { text: 'âšª Waiting...', color: 0x808080 };
        }
    };

    const fetchShopContent = async () => {
        for (const url of CONFIG.TARGET_URLS) {
            for (const proxy of CONFIG.PROXIES) {
                try {
                    log(`Trying proxy for ${url}...`);
                    const res = await fetch(proxy + encodeURIComponent(url), { headers: { 'User-Agent': CONFIG.USER_AGENT } });
                    if (res.ok) {
                        const text = await res.text();
                        if (text.length < MIN_PROXY_RESPONSE_SIZE) {
                            log(`Proxy returned tiny response (${text.length} chars). Skipping.`);
                            continue;
                        }
                        const finalUrl = res.url.includes('allorigins.win') ? url : decodeURIComponent(res.url.replace(proxy, ''));
                        log(`Fetched ${url} (${text.length} chars)`);
                        return { text, finalUrl, urlUsed: url, success: true };
                    }
                } catch (error) {
                    log(`Proxy failed for ${url}: ${error.message}`);
                }
            }
        }
        return { error: 'Failed to fetch page through all proxies.', success: false };
    };
    
    const solveCaptcha = async (text, url) => {
        log('CAPTCHA detected, attempting to solve with CapSolver...');
        const sitekeyMatch = text.match(/data-sitekey=["']([^"']+)["']/);
        if (!sitekeyMatch) {
            log('Could not find sitekey in page HTML.');
            return { error: 'Could not find sitekey.' };
        }

        try {
            const createTaskRes = await fetch('https://api.capsolver.com/createTask', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    clientKey: CAPSOLVER_API_KEY,
                    task: { type: 'ReCaptchaV2TaskProxyless', websiteURL: url, websiteKey: sitekeyMatch[1] }
                })
            });
            const { taskId, errorId, errorDescription } = await createTaskRes.json();
            if (errorId !== 0) throw new Error(errorDescription);

            log(`Task created, ID: ${taskId}. Polling for solution...`);
            while (true) {
                await delay(3000);
                const getResultRes = await fetch('https://api.capsolver.com/getTaskResult', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ clientKey: CAPSOLVER_API_KEY, taskId })
                });
                const result = await getResultRes.json();
                if (result.status === 'ready') {
                    log(`CAPTCHA solved successfully!`);
                    return { solution: result.solution.gRecaptchaResponse };
                }
                if (result.status === 'failed' || result.errorId !== 0) {
                    throw new Error(result.errorDescription || 'Task failed.');
                }
            }
        } catch (error) {
            log(`CapSolver error: ${error.message}`);
            return { error: error.message };
        }
    };

    const analyzeContent = (content) => {
        const { text, finalUrl } = content;
        const lowerCaseText = text.toLowerCase();
        
        if (/queue-it\.net/i.test(finalUrl) || /waiting room|queue-it/i.test(lowerCaseText)) return STATUS_TYPE.IN_QUEUE;
        if (lowerCaseText.includes('pardon our interruption') || lowerCaseText.includes('think you were a bot')) return STATUS_TYPE.BOT_PROTECTION;
        if (lowerCaseText.includes('g-recaptcha') || lowerCaseText.includes('recaptcha')) return STATUS_TYPE.CAPTCHA;
        if (/pokemoncenter\.com/i.test(finalUrl)) {
            return SHOP_AVAILABLE_KEYWORDS.some(kw => lowerCaseText.includes(kw)) ? STATUS_TYPE.AVAILABLE : STATUS_TYPE.MINIMAL_CONTENT;
        }
        return STATUS_TYPE.UNEXPECTED_REDIRECT;
    };
    
    // --- NOTIFICATION LOGIC ---
    const sendAlerts = (statusType, details) => {
        const sendDiscordAlert = async () => {
            if (!state.discordNotificationsEnabled || state.discordWebhooks.length === 0) return;
            log(`Sending Discord alert for status: ${statusType}`);
            const displayInfo = getStatusDisplay(statusType);
            const embed = {
                content: statusType === STATUS_TYPE.AVAILABLE ? '@everyone' : null,
                embeds: [{
                    title: `ðŸŒ€ PokÃ©mon Center Shop Alert! ðŸŒ€`,
                    description: `**Status:** ${displayInfo.text}\n**Details:** ${details}`,
                    color: displayInfo.color,
                    timestamp: new Date().toISOString(),
                    footer: { text: 'Browser Monitor' }
                }]
            };
            for (const webhook of state.discordWebhooks) {
                try {
                    await fetch(webhook, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(embed) });
                } catch (e) { log(`Error sending to webhook: ${e.message}`); }
            }
        };

        const sendEmailAlert = () => {
            if (!state.emailNotificationsEnabled || state.recipientEmails.length === 0) return;
            log(`Sending Email alert for status: ${statusType}`);
            const displayInfo = getStatusDisplay(statusType);
            state.recipientEmails.forEach(email => {
                emailjs.send("service_ahqdaj5", "template_whhvnra", {
                    status: displayInfo.text, details, timestamp: new Date().toLocaleString(), to_email: email
                }).catch(err => log(`Failed to send email to ${email}: ${err}`));
            });
        };
        
        sendDiscordAlert();
        sendEmailAlert();
    };

    // --- MAIN APPLICATION FLOW ---
    const checkShopAccess = async (isTest = false) => {
        log(isTest ? "Starting manual test check..." : "Starting scheduled check...");

        const content = await fetchShopContent();
        let status, details, responseLength = 0;

        if (!content.success) {
            status = STATUS_TYPE.FETCH_ERROR;
            details = content.error;
        } else {
            responseLength = content.text.length;
            status = analyzeContent(content);

            if (status === STATUS_TYPE.CAPTCHA) {
                const captchaResult = await solveCaptcha(content.text, content.urlUsed);
                if (captchaResult.solution) {
                    // In a real scenario, you'd resubmit the form with the token.
                    // For this monitor, we'll assume it worked and re-label the status as available.
                    status = STATUS_TYPE.AVAILABLE;
                    details = `CAPTCHA solved by CapSolver! Assuming shop is accessible.`;
                } else {
                    details = `reCAPTCHA detected but could not be solved. Manual check required.`;
                }
            }
        }
        
        if (!details) {
            details = getStatusDisplay(status).text; // Default details
        }
        
        state.previousStatus = state.currentStatus;
        state.currentStatus = status;
        state.statusDetails = `${details} | Response length: ${responseLength} chars.`;

        updateUI();

        if (state.currentStatus !== state.previousStatus) {
            log(`Status changed from ${state.previousStatus} to ${state.currentStatus}.`);
            sendAlerts(state.currentStatus, state.statusDetails);
            if (state.currentStatus === STATUS_TYPE.AVAILABLE || state.currentStatus === STATUS_TYPE.IN_QUEUE) {
                playBeep();
            }
        }
    };

    const updateUI = () => {
        const displayInfo = getStatusDisplay(state.currentStatus);
        dom.statusText.textContent = displayInfo.text;
        dom.statusDetails.textContent = state.statusDetails;
        dom.lastChecked.textContent = new Date().toLocaleTimeString();
        dom.statusText.className = 'font-semibold';
        if (state.currentStatus === STATUS_TYPE.AVAILABLE) dom.statusText.classList.add('text-green-500');
        else if ([STATUS_TYPE.IN_QUEUE, STATUS_TYPE.BOT_PROTECTION, STATUS_TYPE.CAPTCHA].includes(state.currentStatus)) dom.statusText.classList.add('text-orange-500');
        else dom.statusText.classList.add('text-red-500');
    };
    
    // --- CONTROL FUNCTIONS ---
    const startChecking = () => {
        if (state.intervalId) return;
        if (state.recipientEmails.length === 0 && state.discordWebhooks.length === 0) {
            showFeedback('Please add at least one email or webhook before starting.', true);
            return;
        }
        log("Starting monitoring...");
        showFeedback("Monitoring started!");
        dom.startButton.classList.add('hidden');
        dom.stopButton.classList.remove('hidden');
        
        state.startTime = Date.now();
        state.timerInterval = setInterval(() => dom.runTime.textContent = formatDuration(Date.now() - state.startTime), 1000);
        
        const runCheckAndSchedule = () => {
            checkShopAccess();
            const baseInterval = parseInt(dom.frequencySlider.value) * 60 * 1000;
            const randomizedInterval = baseInterval + (Math.random() * 30000 - 15000);
            state.intervalId = setTimeout(runCheckAndSchedule, randomizedInterval);
        };
        runCheckAndSchedule();
    };

    const stopChecking = () => {
        if (!state.intervalId) return;
        log("Stopping monitoring.");
        showFeedback("Monitoring stopped.", true);
        clearTimeout(state.intervalId);
        clearInterval(state.timerInterval);
        state.intervalId = null;
        state.timerInterval = null;
        dom.runTime.textContent = '0h 0m 0s';
        dom.startButton.classList.remove('hidden');
        dom.stopButton.classList.add('hidden');
    };

    const updateContactList = (listElement, contacts, type) => {
        listElement.innerHTML = '';
        contacts.forEach(contact => {
            const li = document.createElement('li');
            li.innerHTML = `<span>${contact}</span><button class="bg-red-500">Remove</button>`;
            li.querySelector('button').onclick = () => {
                if (type === 'email') state.recipientEmails = state.recipientEmails.filter(e => e !== contact);
                else state.discordWebhooks = state.discordWebhooks.filter(w => w !== contact);
                updateContactList(listElement, type === 'email' ? state.recipientEmails : state.discordWebhooks, type);
                showFeedback(`${type} removed.`);
            };
            listElement.appendChild(li);
        });
    };
    
    // --- EVENT LISTENERS ---
    dom.startButton.addEventListener('click', startChecking);
    dom.stopButton.addEventListener('click', stopChecking);
    dom.testButton.addEventListener('click', () => checkShopAccess(true));
    dom.frequencySlider.addEventListener('input', () => dom.frequencyValue.textContent = dom.frequencySlider.value);

    dom.addEmailButton.addEventListener('click', () => {
        const email = dom.emailInput.value.trim();
        if (email && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
            if (!state.recipientEmails.includes(email)) {
                state.recipientEmails.push(email);
                updateContactList(dom.emailList, state.recipientEmails, 'email');
                dom.emailInput.value = '';
                showFeedback("Email added.");
            } else { showFeedback("Email already in list.", true); }
        } else { showFeedback("Please enter a valid email.", true); }
    });
    
    dom.addWebhookButton.addEventListener('click', () => {
        const webhook = dom.webhookInput.value.trim();
        if (webhook.startsWith('https://discord.com/api/webhooks/')) {
            if (!state.discordWebhooks.includes(webhook)) {
                state.discordWebhooks.push(webhook);
                updateContactList(dom.webhookList, state.discordWebhooks, 'webhook');
                dom.webhookInput.value = '';
                showFeedback("Webhook added.");
            } else { showFeedback("Webhook already in list.", true); }
        } else { showFeedback("Please enter a valid Discord webhook.", true); }
    });

    dom.emailToggleButton.addEventListener('click', () => {
        state.emailNotificationsEnabled = !state.emailNotificationsEnabled;
        dom.emailToggleButton.textContent = `${state.emailNotificationsEnabled ? 'Deactivate' : 'Activate'} Email Alerts`;
        dom.emailToggleButton.classList.toggle('active', state.emailNotificationsEnabled);
        dom.emailToggleButton.classList.toggle('inactive', !state.emailNotificationsEnabled);
        showFeedback(`Email alerts ${state.emailNotificationsEnabled ? 'enabled' : 'disabled'}.`);
    });

    dom.webhookToggleButton.addEventListener('click', () => {
        state.discordNotificationsEnabled = !state.discordNotificationsEnabled;
        dom.webhookToggleButton.textContent = `${state.discordNotificationsEnabled ? 'Deactivate' : 'Activate'} Discord Alerts`;
        dom.webhookToggleButton.classList.toggle('active', state.discordNotificationsEnabled);
        dom.webhookToggleButton.classList.toggle('inactive', !state.discordNotificationsEnabled);
        showFeedback(`Discord alerts ${state.discordNotificationsEnabled ? 'enabled' : 'disabled'}.`);
    });
    
    dom.testAlertsButton.addEventListener('click', () => {
        if (state.recipientEmails.length === 0 && state.discordWebhooks.length === 0) {
            return showFeedback('Add an email or webhook to test.', true);
        }
        log('Sending test alerts...');
        sendAlerts('TEST', 'This is a test alert from the PokÃ©mon Center Monitor. ðŸš€');
        showFeedback('Test alerts sent!');
    });

</script>
</body>
</html>
