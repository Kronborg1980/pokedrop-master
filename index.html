<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kronborg's Ultimate Pok√©mon Checker v3.5</title>
  <style>
    /* Tailwind-like utility classes adapted for TRON theme */
    .bg-black { background-color: #000000; }
    .bg-dark-blue { background-color: #001122; }
    .text-neon-cyan { color: #00ffff; }
    .text-neon-red { color: #ff0040; }
    .text-neon-green { color: #00ff41; }
    .text-neon-yellow { color: #ffff00; }
    .text-white-glow { color: #ffffff; text-shadow: 0 0 5px #00ffff; }
    .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
    .text-2xl { font-size: 1.5rem; line-height: 2rem; }
    .font-bold { font-weight: 700; }
    .font-semibold { font-weight: 600; }
    .p-6 { padding: 1.5rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .w-full { width: 100%; }
    .max-w-md { max-width: 28rem; }
    .rounded { border-radius: 0.25rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .shadow-neon { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.1); }
    .border-neon { border: 1px solid #00ffff; }
    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .min-h-screen { min-height: 100vh; }
    .text-center { text-align: center; }
    .hidden { display: none; }
    
    /* TRON Theme Styles */
    body {
      font-family: 'Orbitron', monospace;
      background: radial-gradient(ellipse at center, #001122 0%, #000011 50%, #000000 100%);
      color: #00ffff;
      position: relative;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #00ffff #001122;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(-45deg, rgba(0,255,255,0.05) 25%, transparent 25%),
        linear-gradient(45deg, rgba(0,255,255,0.05) 25%, transparent 25%),
        linear-gradient(-45deg, transparent 75%, rgba(0,255,255,0.05) 75%),
        linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.05) 75%);
      background-size: 20px 20px;
      z-index: -1;
      animation: gridMove 20s linear infinite;
    }
    @keyframes gridMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(20px, 20px); }
    }
    .tron-card {
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ffff;
      border-radius: 15px;
      padding: 1.5rem;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.05);
      position: relative;
      z-index: 20;
      animation: pulseGlow 3s ease-in-out infinite alternate;
    }
    @keyframes pulseGlow {
      0% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.1); }
      100% { box-shadow: 0 0 40px rgba(0, 255, 255, 0.8), inset 0 0 20px rgba(0, 255, 255, 0.2); }
    }
    input[type="email"], input[type="url"] {
      border: 2px solid #00ffff;
      background: rgba(0, 0, 0, 0.6);
      color: #00ffff;
      padding: 0.6rem 1rem;
      border-radius: 5px;
      transition: all 0.3s ease;
    }
    input[type="email"]:focus, input[type="url"]:focus {
      border-color: #33ffff;
      outline: none;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    }
    input[readonly] {
      background-color: rgba(0, 17, 34, 0.8);
      cursor: not-allowed;
      color: #66ffff;
    }
    button {
      font-weight: 600;
      transition: all 0.3s ease;
      border: 1px solid #00ffff;
      background: transparent;
      color: #00ffff;
      cursor: pointer;
    }
    button:hover {
      color: #33ffff;
      border-color: #33ffff;
      transform: translateY(-2px);
    }
    .input-group {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      animation: fadeIn 0.5s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .input-group input {
      flex-grow: 1;
      margin-right: 0.5rem;
    }
    .remove-button { color: #ff0040; border-color: #ff0040; padding: 0.5rem 0.75rem; border-radius: 0.25rem; }
    .remove-button:hover { background: rgba(255, 0, 64, 0.1); box-shadow: 0 0 10px rgba(255, 0, 64, 0.5); }
    .submit-button { color: #00ff41; border-color: #00ff41; padding: 0.5rem 0.75rem; border-radius: 0.25rem; }
    .submit-button:hover { background: rgba(0, 255, 65, 0.1); box-shadow: 0 0 10px rgba(0, 255, 65, 0.5); }
    
    .add-email-button {
      background: linear-gradient(45deg, rgba(0, 255, 65, 0.2), rgba(0, 255, 255, 0.2));
      color: #00ff41;
      border: 2px solid #00ff41;
      padding: 0.75rem 1rem;
      border-radius: 15px;
      width: 100%;
      margin-bottom: 0.5rem;
    }
    .add-email-button:hover { box-shadow: 0 0 25px rgba(0, 255, 65, 0.8); }

    .pokezonan-button {
      background: linear-gradient(45deg, rgba(255, 0, 64, 0.3), rgba(0, 255, 255, 0.2));
      color: #ff0040;
      border: 2px solid #ff0040;
      padding: 0.5rem 1rem;
      border-radius: 10px;
      margin-left: 0.5rem;
    }
    .pokezonan-button:hover { box-shadow: 0 0 20px rgba(255, 0, 64, 0.8); }

    .toggle-button { padding: 0.75rem; border-radius: 10px; width: 100%; margin-top: 0.5rem; }
    .toggle-button.active { background: rgba(0, 255, 65, 0.2); color: #00ff41; border-color: #00ff41; }
    .toggle-button.inactive { color: #666666; border-color: #666666; }

    .start-button, .stop-button, .test-button, .debug-button { padding: 0.75rem; border-radius: 10px; width: 100%; margin-top: 0.5rem; }
    .start-button { color: #00ffff; border-color: #00ffff; }
    .start-button:hover { background: rgba(0, 255, 255, 0.2); box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
    .stop-button { color: #ff0040; border-color: #ff0040; }
    .stop-button:hover { background: rgba(255, 0, 64, 0.2); box-shadow: 0 0 20px rgba(255, 0, 64, 0.8); }
    .test-button { color: #00ff41; border-color: #00ff41; }
    .test-button:hover { background: rgba(0, 255, 65, 0.2); box-shadow: 0 0 20px rgba(0, 255, 65, 0.8); }
    .debug-button { color: #ffff00; border-color: #ffff00; }
    .debug-button:hover { background: rgba(255, 255, 0, 0.2); box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); }

    input[type="range"] { -webkit-appearance: none; width: 100%; height: 8px; background: rgba(0, 255, 255, 0.2); border-radius: 5px; outline: none; cursor: pointer; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #00ffff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(0, 255, 255, 0.8); }

    .status-feedback { color: #00ff41; font-size: 0.875rem; margin-top: 0.5rem; text-align: center; opacity: 0; transition: opacity 0.5s ease; text-shadow: 0 0 5px #00ff41; }
    .status-feedback.show { opacity: 1; }
    .status-neon-green { color: #00ff41; text-shadow: 0 0 10px #00ff41; }
    .status-neon-red { color: #ff0040; text-shadow: 0 0 10px #ff0040; }
    .status-neon-yellow { color: #ffff00; text-shadow: 0 0 10px #ffff00; }

    h1 { color: #00ffff; text-shadow: 0 0 15px #00ffff; font-weight: 900; letter-spacing: 2px; }
    
    .status-explanation {
      font-size: 0.75rem;
      color: #66ffff;
      margin-top: 0.25rem;
      text-align: center;
      border-top: 1px solid rgba(0, 255, 255, 0.2);
      padding-top: 0.5rem;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body class="bg-black flex items-center justify-center min-h-screen">
  <div class="tron-card p-6 rounded-lg shadow-neon w-full max-w-md">
    <h1 class="text-2xl font-bold text-center mb-2">Pok√©mon Center Queue Detective v3.5</h1>
    <p class="text-gray-600 text-center mb-2 text-sm">Monitors when the Pok√©mon Center shop is open or has waiting lines</p>

    <div id="emailInputsContainer" class="mb-2">
      <label class="block text-sm text-neon-cyan mb-1">üìß Emails for alerts:</label>
      <div class="input-group">
        <input type="email" placeholder="name@example.com" class="w-full border-neon rounded px-3 py-2 email-input" required>
        <button type="button" class="submit-button email-submit-button">Add</button>
      </div>
    </div>
    <button id="addEmailButton" class="add-email-button">‚ûï Add Another Email</button>

    <div id="discordWebhookContainer" class="mb-2">
      <label class="block text-sm text-neon-cyan mb-1">ü§ñ Discord Webhook URL:</label>
      <div class="input-group">
        <input
          type="url"
          id="webhookUrlInput"
          placeholder="https://discord.com/api/webhooks/..."
          class="w-full border-neon rounded px-3 py-2"
          required
        >
        <button type="button" id="submitWebhookButton" class="submit-button">Add Webhook</button>
        <button id="addPokezonanButton" class="pokezonan-button" type="button">Add Pokezonan</button>
      </div>
    </div>

    <div id="emailFeedback" class="status-feedback"></div>

    <div class="mb-2">
      <label for="frequencySlider" class="block text-sm text-neon-cyan mb-1">
        ‚è∞ Check every: <span id="frequencyValue" class="font-semibold text-white-glow">10</span> minutes
      </label>
      <input type="range" id="frequencySlider" min="1" max="60" value="10">
      <p class="text-xs text-neon-cyan mt-1">(Longer intervals = less chance of being blocked)</p>
    </div>

    <div id="status" class="text-center mb-2 p-3 border-neon rounded-lg">
      <p class="text-lg">üîç Current Status: <span id="statusText" class="font-semibold status-neon-red">Ready to Start</span></p>
      <p class="text-sm text-neon-cyan">‚è±Ô∏è Last checked: <span id="lastChecked">Not yet checked</span></p>
      <p class="text-sm text-neon-cyan">‚è≥ Running time: <span id="runTime">0h 0m 0s</span></p>
      <p class="text-sm text-neon-cyan">üìã Details: <span id="statusDetails">Waiting for first check...</span></p>
      <div id="statusExplanation" class="status-explanation">
        <strong>What this means:</strong> System is ready to begin monitoring
      </div>
      <p id="warningMsg" class="text-xs text-neon-yellow hidden mt-1">‚ö†Ô∏è Tab is minimized! Keep tab active for best results!</p>
    </div>

    <div class="flex space-x-2 mb-2">
      <button id="startButton" class="start-button flex-1">‚ñ∂Ô∏è Start Monitoring</button>
      <button id="stopButton" class="stop-button flex-1 hidden">‚èπÔ∏è Stop Monitoring</button>
    </div>
    
    <button id="emailToggleButton" class="toggle-button active">üîî Email Alerts: ON</button>
    <button id="discordToggleButton" class="toggle-button active">ü§ñ Discord Alerts: ON</button>
    
    <div class="flex space-x-2 mt-2">
      <button id="testEmailButton" class="test-button flex-1">üß™ Test Alerts</button>
      <button id="debugButton" class="debug-button flex-1">üêõ Debug Check</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4.4.1/dist/email.min.js"></script>
  <script>
    // --- AUDIO ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playBeep() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'square';
        oscillator.frequency.value = 880;
        gainNode.gain.value = 0.1;
        oscillator.start();
        setTimeout(() => { oscillator.stop(); }, 200);
    }
    function playThreeBeeps() {
        playBeep();
        setTimeout(playBeep, 400);
        setTimeout(playBeep, 800);
    }
    function playSuccessBeep() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
        oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
        oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.2); // G5
        gainNode.gain.value = 0.1;
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.3);
    }

    if (typeof emailjs === 'undefined') {
      console.error('EmailJS failed to load.');
      alert('Email functionality is unavailable.');
    } else {
      emailjs.init({ publicKey: "8w7eu6mrg3lRl6ta3" });
    }

    // --- DOM Selectors ---
    const statusText = document.getElementById('statusText');
    const lastChecked = document.getElementById('lastChecked');
    const statusDetails = document.getElementById('statusDetails');
    const statusExplanation = document.getElementById('statusExplanation');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const testEmailButton = document.getElementById('testEmailButton');
    const debugButton = document.getElementById('debugButton');
    const emailToggleButton = document.getElementById('emailToggleButton');
    const discordToggleButton = document.getElementById('discordToggleButton');
    const webhookUrlInput = document.getElementById('webhookUrlInput');
    const submitWebhookButton = document.getElementById('submitWebhookButton');
    const addPokezonanButton = document.getElementById('addPokezonanButton');
    const runTime = document.getElementById('runTime');
    const emailInputsContainer = document.getElementById('emailInputsContainer');
    const addEmailButton = document.getElementById('addEmailButton');
    const emailFeedback = document.getElementById('emailFeedback');
    const frequencySlider = document.getElementById('frequencySlider');
    const frequencyValue = document.getElementById('frequencyValue');
    const warningMsg = document.getElementById('warningMsg');

    // --- Global Variables ---
    let intervalId = null;
    let startTime = null;
    let timerInterval = null;
    let currentCheckInterval = 10 * 60 * 1000;
    let emailNotificationsEnabled = true;
    let discordNotificationsEnabled = true;
    let discordWebhookUrl = null;

    // --- Utility Functions ---
    function showEmailFeedback(message) {
      emailFeedback.textContent = message;
      emailFeedback.classList.add('show');
      setTimeout(() => emailFeedback.classList.remove('show'), 2000);
    }

    function getRandomInterval(baseInterval) {
      const variation = Math.floor(Math.random() * 30000) + 30000;
      return baseInterval + variation;
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      return `${hours}h ${minutes}m ${secs}s`;
    }

    function updateRunTime() {
      if (startTime) {
        const now = Date.now();
        runTime.textContent = formatDuration(now - startTime);
      }
    }

    function startTimer() {
      if (!startTime) {
        startTime = Date.now();
        timerInterval = setInterval(updateRunTime, 1000);
      }
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      startTime = null;
      runTime.textContent = '0h 0m 0s';
    }

    function updateStatusExplanation(message) {
      statusExplanation.innerHTML = `<strong>What this means:</strong> ${message}`;
    }

    // --- Content Analysis Functions ---
    function analyzeContent(text) {
      const lowerText = text.toLowerCase();
      const result = {
        isQueue: false,
        isShop: false,
        isBlocked: false,
        hasETB: false,
        queuePosition: null,
        queueType: ''
      };

      // QUEUE DETECTION - Pok√©mon Center uses Queue-it system
      const queuePatterns = [
        { pattern: /queue-it/, type: 'Queue-it System' },
        { pattern: /waiting[\s\S]*?room/, type: 'Waiting Room' },
        { pattern: /you[\s\S]*?are[\s\S]*?in[\s\S]*?line/, type: 'In Line' },
        { pattern: /estimated[\s\S]*?wait/, type: 'Estimated Wait' },
        { pattern: /users[\s\S]*?ahead/, type: 'Users Ahead' },
        { pattern: /queue[\s\S]*?position/, type: 'Queue Position' },
        { pattern: /virtual[\s\S]*?waiting/, type: 'Virtual Waiting' },
        { pattern: /\/queue\//, type: 'Queue URL' },
        { pattern: /queueid=/, type: 'Queue ID' },
        { pattern: /queue\.js/, type: 'Queue Script' },
        { pattern: /holding[\s\S]*?page/, type: 'Holding Page' }
      ];

      // BLOCKED DETECTION
      const blockedPatterns = [
        /cloudflare/i,
        /access[\s\S]*?denied/i,
        /just[\s\S]*?moment/i,
        /captcha/i,
        /challenge/i,
        /security[\s\S]*?check/i,
        /distil/i,
        /incapsula/i,
        /blocked/i,
        /forbidden/i
      ];

      // SHOP ACCESSIBLE DETECTION
      const shopPatterns = [
        /pok√©mon[\s\S]*?center/i,
        /pokemon[\s\S]*?center/i,
        /my[\s\S]*?cart/i,
        /add[\s\S]*?to[\s\S]*?cart/i,
        /product[\s\S]*?details/i,
        /trading[\s\S]*?card[\s\S]*?game/i,
        /add to cart/i,
        /out of stock/i,
        /product-title/i,
        /shop[\s\S]*?now/i,
        /sign in/i,
        /register/i,
        /search products/i
      ];

      // ETB DETECTION
      const etbPatterns = [
        /elite[\s\S]*?trainer[\s\S]*?box/i,
        /\betb\b/i,
        /temporal[\s\S]*?forces/i,
        /151[\s\S]*?set/i,
        /booster[\s\S]*?box/i,
        /paldea[\s\S]*?evolved/i,
        /scarlet[\s\S]*?violet/i
      ];

      // Check for queue
      for (const item of queuePatterns) {
        if (item.pattern.test(lowerText)) {
          result.isQueue = true;
          result.queueType = item.type;
          
          // Try to extract queue position
          const positionMatch = lowerText.match(/(\d+,?\d*)\s*(users? ahead|people ahead|ahead of you)/i) ||
                              lowerText.match(/position\s*[#:]?\s*(\d+,?\d*)/i) ||
                              lowerText.match(/waiting:\s*(\d+,?\d*)/i);
          
          if (positionMatch && positionMatch[1]) {
            result.queuePosition = positionMatch[1];
          }
          break;
        }
      }

      // Check for blocking
      for (const pattern of blockedPatterns) {
        if (pattern.test(lowerText)) {
          result.isBlocked = true;
          break;
        }
      }

      // Check for shop (only if not queue or blocked)
      if (!result.isQueue && !result.isBlocked) {
        for (const pattern of shopPatterns) {
          if (pattern.test(lowerText)) {
            result.isShop = true;
            break;
          }
        }
      }

      // Check for ETB
      for (const pattern of etbPatterns) {
        if (pattern.test(lowerText)) {
          result.hasETB = true;
          break;
        }
      }

      return result;
    }

    // --- Notification Functions ---
    async function sendDiscordMessage(status, details, isETB = false) {
      if (!discordNotificationsEnabled || !discordWebhookUrl) return;
      
      let color, title, thumbnail;
      
      if (isETB) {
        color = 16776960; // Yellow
        title = 'üî• POK√âMON ETB AVAILABLE! üöÄ';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/384.png';
      } else if (status.includes('Accessible')) {
        color = 3066993; // Green
        title = '‚úÖ SHOP IS OPEN - NO QUEUE!';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png';
      } else if (status.includes('Queue')) {
        color = 15158332; // Red
        title = '‚ö†Ô∏è WAITING LINE ACTIVE';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/143.png';
      } else if (status.includes('Blocked')) {
        color = 10181046; // Purple
        title = 'üö® ANTI-BOT PROTECTION';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png';
      } else {
        color = 3447003; // Blue
        title = 'üì° STATUS UPDATE';
        thumbnail = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/137.png';
      }
      
      const payload = {
        embeds: [{
          title: title,
          description: `**Status:** ${status}\n**Details:** ${details}\n\n*Checked at: ${new Date().toLocaleTimeString()}*`,
          color: color,
          thumbnail: { url: thumbnail },
          timestamp: new Date().toISOString(),
          footer: { text: 'Pok√©mon Center Queue Detective v3.5' }
        }]
      };
      
      try {
        await fetch(discordWebhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
      } catch (error) {
        console.error('Discord Error:', error);
      }
    }

    function sendEmail(status, details, recipientEmails, isETB = false) {
      if (!emailNotificationsEnabled || !recipientEmails.length) return;
      
      let subject = isETB ? 'üö® POK√âMON ETB AVAILABLE! üöÄ' : `Pok√©mon Center: ${status}`;
      let coolDetails = isETB 
        ? `**üî• URGENT ALERT! üî•**\n\n${status}\n\n${details}\n\nüéÆ ELITE TRAINER BOX DETECTED! üéÆ\n\nTime to shop: ${new Date().toLocaleTimeString()}`
        : `**üì¢ POK√âMON CENTER UPDATE**\n\nStatus: ${status}\n\nDetails: ${details}\n\nChecked: ${new Date().toLocaleTimeString()}`;
      
      recipientEmails.forEach(email => {
        emailjs.send("service_ahqdaj5", "template_whhvnra", {
          status: subject,
          details: coolDetails,
          timestamp: new Date().toLocaleString(),
          to_email: email
        }).then(() => {
          console.log('Email sent to:', email);
        }).catch(error => {
          console.error('Email error:', error);
        });
      });
    }

    function testEmail() {
      const inputs = document.querySelectorAll('.email-input');
      const emails = Array.from(inputs).filter(i => i.hasAttribute('readonly')).map(i => i.value);
      
      if (!emails.length && !discordWebhookUrl) {
        alert('Please add an email or webhook first!');
        return;
      }

      playSuccessBeep();
      
      if(emails.length && emailNotificationsEnabled) {
          sendEmail('üß™ Test Alert - System Working', 'This is a test notification to confirm your alerts are working correctly!', emails);
      }
      if(discordWebhookUrl && discordNotificationsEnabled) {
          sendDiscordMessage('üß™ Test Alert', 'System is functioning normally!');
      }
      showEmailFeedback('‚úÖ Test alerts sent! Check your email/Discord.');
    }

    // --- Core Checking Logic ---
    async function checkShopAccess(isDebug = false) {
      const emailInputs = document.querySelectorAll('.email-input');
      const currentEmails = Array.from(emailInputs)
        .filter(input => input.hasAttribute('readonly'))
        .map(input => input.value.trim());

      const now = new Date().toLocaleTimeString();
      lastChecked.textContent = now;

      if (isDebug) {
        statusDetails.textContent = 'Debug check in progress...';
        updateStatusExplanation('Performing a single debug check to test connectivity');
      }

      // Try multiple approaches to get content
      let text = '';
      let finalUrl = '';
      let success = false;
      let methodUsed = '';

      const methods = [
        // Method 1: Try robots.txt (often less protected)
        async () => {
          methodUsed = 'robots.txt check';
          try {
            const response = await fetch('https://www.pokemoncenter.com/robots.txt?' + Date.now(), {
              headers: { 'User-Agent': 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)' },
              signal: AbortSignal.timeout(8000)
            });
            if (response.ok) {
              text = await response.text();
              finalUrl = response.url;
              return true;
            }
          } catch { return false; }
        },

        // Method 2: Try direct access with realistic browser headers
        async () => {
          methodUsed = 'direct access';
          const headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0'
          };

          try {
            const response = await fetch('https://www.pokemoncenter.com?' + Date.now(), {
              headers: headers,
              mode: 'cors',
              credentials: 'omit',
              referrerPolicy: 'no-referrer',
              signal: AbortSignal.timeout(10000)
            });
            
            if (response.ok) {
              text = await response.text();
              finalUrl = response.url;
              return true;
            }
          } catch { return false; }
        },

        // Method 3: Use a CORS proxy
        async () => {
          methodUsed = 'CORS proxy';
          try {
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent('https://www.pokemoncenter.com?' + Date.now())}`;
            const response = await fetch(proxyUrl, {
              signal: AbortSignal.timeout(10000)
            });
            
            if (response.ok) {
              const data = await response.json();
              text = data.contents || '';
              finalUrl = 'https://www.pokemoncenter.com';
              return true;
            }
          } catch { return false; }
        },

        // Method 4: Try a different endpoint (sitemap)
        async () => {
          methodUsed = 'sitemap check';
          try {
            const response = await fetch('https://www.pokemoncenter.com/sitemap.xml?' + Date.now(), {
              signal: AbortSignal.timeout(8000)
            });
            
            if (response.ok) {
              text = await response.text();
              finalUrl = response.url;
              return true;
            }
          } catch { return false; }
        }
      ];

      // Try each method in order
      for (const method of methods) {
        try {
          success = await method();
          if (success && text && text.length > 100) {
            break;
          }
        } catch (error) {
          console.log(`Method failed: ${methodUsed}`, error);
          continue;
        }
        
        // Small delay between attempts
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      // ANALYZE THE RESULTS
      let status = '';
      let details = '';
      let shouldAlert = false;
      let isETBAlert = false;
      let explanation = '';

      if (!success || !text) {
        // Could not get any content
        status = '‚ùå Cannot Reach Site';
        details = 'Failed to load Pok√©mon Center. Possible reasons:';
        details += '\n‚Ä¢ Site is down or having issues';
        details += '\n‚Ä¢ Your internet connection is blocked';
        details += '\n‚Ä¢ Pok√©mon Center is blocking automated checks';
        explanation = 'The system cannot connect to Pok√©mon Center. This could be a temporary outage or your connection is being blocked.';
        statusText.className = 'font-semibold status-neon-red';
        shouldAlert = true;
      }
      else if (text.length < 100) {
        // Got response but it's too small (likely error page)
        status = 'üõ°Ô∏è Anti-Bot Protection';
        details = `Received very small response (${text.length} characters). This usually means:`;
        details += '\n‚Ä¢ Pok√©mon Center is showing a CAPTCHA';
        details += '\n‚Ä¢ Cloudflare challenge page is active';
        details += '\n‚Ä¢ The site is blocking automated access';
        explanation = 'Pok√©mon Center is detecting automated traffic and showing a security challenge instead of the real site.';
        statusText.className = 'font-semibold status-neon-yellow';
        shouldAlert = true;
      }
      else {
        // We have content to analyze
        const analysis = analyzeContent(text);
        
        if (analysis.isBlocked) {
          status = 'üõ°Ô∏è Blocked by Security';
          details = 'Pok√©mon Center is actively blocking this check with security measures.';
          details += '\nThis is common when checking too frequently.';
          explanation = 'The site has anti-bot protection that is preventing access. Try increasing the check interval.';
          statusText.className = 'font-semibold status-neon-red';
          shouldAlert = true;
        }
        else if (analysis.isQueue) {
          status = '‚è≥ Waiting Line Active';
          details = `QUEUE DETECTED: ${analysis.queueType}`;
          if (analysis.queuePosition) {
            details += `\nYour position in line: #${analysis.queuePosition}`;
            details += `\nThere are ${analysis.queuePosition} users ahead of you`;
          } else {
            details += '\nYou are in a virtual waiting room';
            details += '\nPosition in line not specified';
          }
          explanation = 'Pok√©mon Center has a waiting line (queue) active. You cannot shop until your turn comes up.';
          statusText.className = 'font-semibold status-neon-yellow';
          shouldAlert = true;
          playThreeBeeps();
        }
        else if (analysis.isShop) {
          if (analysis.hasETB) {
            status = 'üéÆ ETB AVAILABLE!';
            details = 'SHOP IS OPEN WITH NO WAITING LINE!';
            details += '\n‚≠ê ELITE TRAINER BOX PRODUCTS FOUND!';
            details += '\nüî• GO SHOPPING NOW!';
            explanation = 'The shop is accessible AND Elite Trainer Box products are available! No waiting line!';
            statusText.className = 'font-semibold status-neon-green';
            shouldAlert = true;
            isETBAlert = true;
            playSuccessBeep();
          } else {
            status = '‚úÖ Shop Open - No Queue';
            details = 'Pok√©mon Center is accessible with no waiting line!';
            details += '\nYou can browse and shop normally';
            explanation = 'The shop is fully accessible with no waiting lines or queues. Perfect time to shop!';
            statusText.className = 'font-semibold status-neon-green';
            // Don't alert for normal shop access (would be too spammy)
            shouldAlert = false;
          }
        }
        else {
          // Content but can't determine status
          status = 'ü§î Unknown Status';
          details = `Received ${text.length} characters but cannot identify page type`;
          details += `\nMethod used: ${methodUsed}`;
          details += `\nURL: ${finalUrl.substring(0, 50)}...`;
          explanation = 'Got content from Pok√©mon Center but cannot determine if it\'s a shop, queue, or error page.';
          statusText.className = 'font-semibold text-white-glow';
        }
      }

      // Update display
      statusText.textContent = status;
      statusDetails.textContent = details;
      updateStatusExplanation(explanation);

      // Check if we should send alerts
      const prevStatus = statusText.dataset.previousStatus || '';
      
      if (shouldAlert && prevStatus !== status) {
        if (isETBAlert) {
          sendEmail(status, details, currentEmails, true);
          sendDiscordMessage(status, details, true);
        } else {
          sendEmail(status, details, currentEmails);
          sendDiscordMessage(status, details);
        }
      }
      
      statusText.dataset.previousStatus = status;

      if (isDebug) {
        showEmailFeedback(`‚úÖ Debug check complete using: ${methodUsed}`);
      }
    }

    function startChecking() {
      const emails = document.querySelectorAll('.email-input[readonly]').length;
      const webhook = webhookUrlInput.hasAttribute('readonly');
      
      if (!emails && !webhook) {
        alert('Please add at least one email or Discord webhook first!');
        return;
      }

      if (intervalId) clearTimeout(intervalId);
      
      function scheduleNext() {
        const mins = parseInt(frequencySlider.value);
        const base = mins * 60000;
        const nextDelay = getRandomInterval(base);
        
        intervalId = setTimeout(() => {
            checkShopAccess();
            scheduleNext();
        }, nextDelay);
      }

      checkShopAccess();
      scheduleNext();

      startButton.classList.add('hidden');
      stopButton.classList.remove('hidden');
      statusText.textContent = 'üîç Monitoring Active';
      statusDetails.textContent = 'System is checking Pok√©mon Center regularly';
      updateStatusExplanation('The system is actively checking for queues and shop availability at regular intervals.');
      startTimer();
    }
    
    function stopChecking() {
      if (intervalId) clearTimeout(intervalId);
      stopTimer();
      startButton.classList.remove('hidden');
      stopButton.classList.add('hidden');
      statusText.textContent = '‚è∏Ô∏è Monitoring Stopped';
      statusDetails.textContent = 'System is paused. Click Start to resume.';
      updateStatusExplanation('Monitoring is paused. No checks will be performed until you start again.');
    }

    // --- Event Listeners ---
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          warningMsg.classList.remove('hidden');
          warningMsg.textContent = '‚ö†Ô∏è Tab is in background! Monitoring may be less reliable when tab is not active.';
        } else {
          warningMsg.classList.add('hidden');
        }
    });

    emailToggleButton.addEventListener('click', () => {
      emailNotificationsEnabled = !emailNotificationsEnabled;
      emailToggleButton.classList.toggle('active');
      emailToggleButton.classList.toggle('inactive');
      emailToggleButton.textContent = emailNotificationsEnabled ? 'üîî Email Alerts: ON' : 'üîï Email Alerts: OFF';
      showEmailFeedback(emailNotificationsEnabled ? '‚úÖ Email alerts enabled' : 'üîï Email alerts disabled');
    });

    discordToggleButton.addEventListener('click', () => {
      discordNotificationsEnabled = !discordNotificationsEnabled;
      discordToggleButton.classList.toggle('active');
      discordToggleButton.classList.toggle('inactive');
      discordToggleButton.textContent = discordNotificationsEnabled ? 'ü§ñ Discord Alerts: ON' : 'ü§ñ Discord Alerts: OFF';
      showEmailFeedback(discordNotificationsEnabled ? '‚úÖ Discord alerts enabled' : 'üîï Discord alerts disabled');
    });

    submitWebhookButton.addEventListener('click', () => {
      if (webhookUrlInput.hasAttribute('readonly')) {
          webhookUrlInput.removeAttribute('readonly');
          webhookUrlInput.value = '';
          discordWebhookUrl = null;
          submitWebhookButton.textContent = 'Add Webhook';
          submitWebhookButton.classList.replace('remove-button', 'submit-button');
          showEmailFeedback('‚úÖ Webhook removed');
      } else {
          if(!webhookUrlInput.value.includes('discord.com/api/webhooks')) {
              alert('Please enter a valid Discord webhook URL');
              return;
          }
          webhookUrlInput.setAttribute('readonly', true);
          discordWebhookUrl = webhookUrlInput.value;
          submitWebhookButton.textContent = 'Remove';
          submitWebhookButton.classList.replace('submit-button', 'remove-button');
          showEmailFeedback('‚úÖ Discord webhook added!');
      }
    });

    // --- POKEZONAN BUTTON LOGIC ---
    addPokezonanButton.addEventListener('click', () => {
        const pokezonanUrl = "https://discord.com/api/webhooks/1418654823745716436/vuMKu1s095Cq3BfU06OF_Z_mwxG39zHppHJ3c4BX5X38WuJFWPGhIZdopWTEEXlophiN";
        
        discordWebhookUrl = pokezonanUrl;
        webhookUrlInput.value = "Pokezonan Webhook Loaded üîí";
        webhookUrlInput.setAttribute('readonly', true);
        submitWebhookButton.textContent = 'Remove';
        submitWebhookButton.classList.replace('submit-button', 'remove-button');
        showEmailFeedback('‚úÖ Pokezonan webhook connected! üéÆ');
    });

    // Email management
    function setupEmailButton(btn) {
        btn.addEventListener('click', (e) => {
            const input = e.target.previousElementSibling;
            if(input.value.includes('@') && input.value.includes('.')) {
                input.setAttribute('readonly', true);
                e.target.textContent = 'Remove';
                e.target.className = 'remove-button';
                e.target.onclick = () => {
                  e.target.parentElement.remove();
                  showEmailFeedback('‚úÖ Email removed');
                };
                showEmailFeedback('‚úÖ Email added for alerts');
            } else {
                alert('Please enter a valid email address');
            }
        });
    }

    addEmailButton.addEventListener('click', () => {
        const div = document.createElement('div');
        div.className = 'input-group';
        div.innerHTML = `<input type="email" placeholder="name@example.com" class="w-full border-neon rounded px-3 py-2 email-input"><button type="button" class="submit-button email-submit-button">Add</button>`;
        emailInputsContainer.appendChild(div);
        setupEmailButton(div.querySelector('button'));
    });
    
    // Initialize first email button
    setupEmailButton(document.querySelector('.email-submit-button'));

    frequencySlider.addEventListener('input', function() {
      frequencyValue.textContent = this.value;
      currentCheckInterval = this.value * 60 * 1000;
      showEmailFeedback(`‚úÖ Check interval set to ${this.value} minutes`);
    });

    startButton.addEventListener('click', startChecking);
    stopButton.addEventListener('click', stopChecking);
    testEmailButton.addEventListener('click', testEmail);
    debugButton.addEventListener('click', () => checkShopAccess(true));
    
    // Initialize status data attribute
    statusText.dataset.previousStatus = '';
    
    // Initial explanation
    updateStatusExplanation('Click "Start Monitoring" to begin checking for Pok√©mon Center queues and availability. The system will alert you when Elite Trainer Boxes are available or when waiting lines start/end.');
  </script>
</body>
</html>
