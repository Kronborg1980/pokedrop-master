<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Store Accessibility Monitor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      width: 100%;
      max-width: 500px;
      padding: 40px;
    }
    
    h1 {
      color: #333;
      font-size: 28px;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      color: #555;
      font-weight: 500;
      font-size: 14px;
    }
    
    input[type="email"],
    input[type="url"] {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    input[type="email"]:focus,
    input[type="url"]:focus {
      outline: none;
      border-color: #667eea;
    }
    
    input[readonly] {
      background-color: #f5f5f5;
      color: #777;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      flex: 1;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }
    
    .btn-secondary {
      background: #f0f0f0;
      color: #666;
      border: 2px solid #e0e0e0;
    }
    
    .btn-secondary:hover {
      background: #e0e0e0;
    }
    
    .btn-danger {
      background: #ff4757;
      color: white;
    }
    
    .btn-danger:hover {
      background: #ff3742;
    }
    
    .btn-success {
      background: #2ed573;
      color: white;
    }
    
    .btn-success:hover {
      background: #25cc6a;
    }
    
    .btn-warning {
      background: #ffa502;
      color: white;
    }
    
    .btn-warning:hover {
      background: #ff9500;
    }
    
    .btn-info {
      background: #3742fa;
      color: white;
    }
    
    .btn-info:hover {
      background: #2f35e6;
    }
    
    .status-card {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 25px;
      margin-top: 30px;
      border-left: 5px solid #667eea;
    }
    
    .status-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    
    .status-row:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .status-label {
      color: #666;
      font-weight: 500;
    }
    
    .status-value {
      color: #333;
      font-weight: 600;
      text-align: right;
      max-width: 60%;
    }
    
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .status-good { background: #2ed573; }
    .status-warning { background: #ffa502; }
    .status-danger { background: #ff4757; }
    .status-neutral { background: #747d8c; }
    .status-queue { background: #ff4757; animation: pulse 2s infinite; }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .hidden { display: none; }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    
    .slider-container {
      margin: 20px 0;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e0e0e0;
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .feedback {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      display: none;
    }
    
    .feedback.show {
      display: block;
      animation: fadeIn 0.3s;
    }
    
    .feedback-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .feedback-error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .feedback-info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .contact-link {
      text-align: center;
      margin-top: 20px;
      font-size: 12px;
      color: #666;
    }
    
    .contact-link a {
      color: #667eea;
      text-decoration: none;
    }
    
    .queue-position {
      font-size: 18px;
      font-weight: bold;
      color: #ff4757;
      margin-top: 5px;
    }
    
    .status-icon {
      font-size: 20px;
      margin-right: 5px;
    }
    
    .quick-buttons {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
    
    .quick-buttons button {
      padding: 8px 12px;
      font-size: 12px;
    }
    
    .progress-bar {
      width: 100%;
      height: 4px;
      background: #e0e0e0;
      border-radius: 2px;
      margin-top: 5px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: #667eea;
      width: 0%;
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üõí Store Status Monitor</h1>
    <p class="subtitle">Get notified when popular online stores are accessible</p>
    
    <div class="form-group">
      <label>Email for notifications:</label>
      <div class="button-group">
        <input type="email" id="emailInput" placeholder="your.email@example.com">
        <button id="addEmailBtn" class="btn-primary">Add</button>
      </div>
    </div>
    
    <div class="form-group">
      <label>Discord Webhook (optional):</label>
      <div class="button-group">
        <input type="url" id="webhookInput" placeholder="https://discord.com/api/webhooks/...">
        <button id="addWebhookBtn" class="btn-secondary">Connect</button>
      </div>
    </div>
    
    <div id="feedback" class="feedback"></div>
    
    <div class="slider-container">
      <label>Check frequency: <span id="frequencyValue">5</span> minutes</label>
      <input type="range" id="frequencySlider" min="1" max="60" value="5">
      <div class="progress-bar">
        <div id="checkProgress" class="progress-fill"></div>
      </div>
      <div class="quick-buttons">
        <button class="btn-secondary" data-minutes="1">1 min</button>
        <button class="btn-secondary" data-minutes="2">2 min</button>
        <button class="btn-secondary" data-minutes="5">5 min</button>
        <button class="btn-secondary" data-minutes="10">10 min</button>
        <button class="btn-secondary" data-minutes="15">15 min</button>
        <button class="btn-secondary" data-minutes="30">30 min</button>
      </div>
    </div>
    
    <div class="checkbox-group">
      <input type="checkbox" id="emailToggle" checked>
      <label for="emailToggle">Enable email notifications</label>
    </div>
    
    <div class="checkbox-group">
      <input type="checkbox" id="discordToggle" checked>
      <label for="discordToggle">Enable Discord notifications</label>
    </div>
    
    <div class="button-group">
      <button id="startBtn" class="btn-success">‚ñ∂ Start Monitoring</button>
      <button id="stopBtn" class="btn-danger hidden">‚è∏ Stop Monitoring</button>
    </div>
    
    <div class="button-group" style="margin-top: 10px;">
      <button id="testBtn" class="btn-warning">Test Notifications</button>
      <button id="manualCheckBtn" class="btn-info">Check Now</button>
    </div>
    
    <div class="status-card">
      <div class="status-row">
        <span class="status-label">Store Status:</span>
        <span class="status-value">
          <span id="statusIndicator" class="status-indicator status-neutral"></span>
          <span id="statusText">Ready to monitor</span>
        </span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Queue Status:</span>
        <span class="status-value" id="queueStatus">Not checked</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Last Check:</span>
        <span class="status-value" id="lastCheck">Never</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Running Time:</span>
        <span class="status-value" id="runTime">0h 0m</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Next Check In:</span>
        <span class="status-value" id="nextCheck">--:--</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Details:</span>
        <span class="status-value" id="statusDetails">Waiting for first check</span>
      </div>
      
      <div id="queuePosition" class="queue-position hidden"></div>
    </div>
    
    <div class="contact-link">
      <p>Monitor your favorite stores for accessibility and queue status</p>
    </div>
  </div>

  <script>
    // ============================================
    // STORE ACCESS MONITOR - COMPLETE VERSION
    // ============================================
    
    const CONFIG = {
      storeName: 'Collectible Store',
      userAgents: [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15'
      ]
    };
    
    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      emailInput: document.getElementById('emailInput'),
      webhookInput: document.getElementById('webhookInput'),
      addEmailBtn: document.getElementById('addEmailBtn'),
      addWebhookBtn: document.getElementById('addWebhookBtn'),
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      testBtn: document.getElementById('testBtn'),
      manualCheckBtn: document.getElementById('manualCheckBtn'),
      frequencySlider: document.getElementById('frequencySlider'),
      frequencyValue: document.getElementById('frequencyValue'),
      emailToggle: document.getElementById('emailToggle'),
      discordToggle: document.getElementById('discordToggle'),
      statusText: document.getElementById('statusText'),
      statusIndicator: document.getElementById('statusIndicator'),
      queueStatus: document.getElementById('queueStatus'),
      lastCheck: document.getElementById('lastCheck'),
      runTime: document.getElementById('runTime'),
      nextCheck: document.getElementById('nextCheck'),
      statusDetails: document.getElementById('statusDetails'),
      feedback: document.getElementById('feedback'),
      queuePosition: document.getElementById('queuePosition'),
      checkProgress: document.getElementById('checkProgress')
    };
    
    // ============================================
    // STATE MANAGEMENT
    // ============================================
    let state = {
      isRunning: false,
      checkInterval: null,
      progressInterval: null,
      runTimer: null,
      startTime: null,
      nextCheckTime: null,
      emails: JSON.parse(localStorage.getItem('storeMonitor_emails')) || [],
      discordWebhook: localStorage.getItem('storeMonitor_webhook') || null,
      emailEnabled: true,
      discordEnabled: true,
      lastStatus: 'idle',
      checkCounter: 0,
      currentQueue: null
    };
    
    // ============================================
    // STEALTH CHECKING METHODS
    // ============================================
    
    async function checkStoreStatus() {
      state.checkCounter++;
      const checkTime = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      elements.lastCheck.textContent = checkTime;
      
      updateStatus('Checking...', 'neutral', 'Analyzing store accessibility...');
      elements.queueStatus.textContent = 'Checking...';
      elements.queuePosition.classList.add('hidden');
      
      // Reset progress bar
      elements.checkProgress.style.width = '0%';
      
      try {
        // Try multiple methods to detect queue status
        const methods = [
          checkViaPublicAPI,
          checkViaDNSAnalysis,
          checkViaNetworkProbe,
          checkViaPortScan,
          checkViaResponseTime
        ];
        
        const methodIndex = (state.checkCounter - 1) % methods.length;
        const currentMethod = methods[methodIndex];
        
        showFeedback(`Using method ${methodIndex + 1}/${methods.length}`, 'info');
        
        // Simulate progress
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress += 10;
          elements.checkProgress.style.width = `${progress}%`;
          if (progress >= 90) clearInterval(progressInterval);
        }, 100);
        
        const result = await currentMethod();
        
        clearInterval(progressInterval);
        elements.checkProgress.style.width = '100%';
        
        if (result) {
          // Update based on result
          if (result.queueDetected) {
            state.currentQueue = result.queuePosition || 'active';
            
            updateStatus('Queue Detected', 'queue', 
              `${result.method} detected a waiting system`);
            
            elements.queueStatus.textContent = '‚ö†Ô∏è Waiting Line Active';
            elements.queueStatus.style.color = '#ff4757';
            
            if (result.queuePosition) {
              elements.queuePosition.textContent = `Estimated position: #${result.queuePosition}`;
              elements.queuePosition.classList.remove('hidden');
            }
            
            // Send notification if status changed
            if (state.lastStatus !== 'queue') {
              sendNotifications('üö® Queue Detected',
                `A waiting line has been detected at the store.\n\n` +
                `Detection Method: ${result.method}\n` +
                `Time: ${checkTime}\n` +
                (result.queuePosition ? `Estimated Position: ${result.queuePosition}\n` : '') +
                `\nCheck the store manually to confirm.`);
              playAlertSound();
            }
            
            state.lastStatus = 'queue';
            
          } else if (result.blocked) {
            updateStatus('Access Restricted', 'warning',
              'Store has enhanced security measures');
            
            elements.queueStatus.textContent = 'üõ°Ô∏è Security Active';
            elements.queueStatus.style.color = '#ffa502';
            
          } else {
            // No queue detected - store is accessible
            state.currentQueue = null;
            
            updateStatus('Store Accessible', 'good',
              `${result.method} indicates normal operations`);
            
            elements.queueStatus.textContent = '‚úÖ No Queue Detected';
            elements.queueStatus.style.color = '#2ed573';
            
            // Only send notification if we were previously in queue
            if (state.lastStatus === 'queue') {
              sendNotifications('‚úÖ Queue Cleared',
                `The waiting line appears to have cleared.\n\n` +
                `Store should now be accessible.\n` +
                `Time: ${checkTime}\n\n` +
                `You can try accessing the store now.`);
              playSuccessSound();
            }
            
            state.lastStatus = 'accessible';
          }
          
          elements.statusDetails.textContent = result.details;
          
        } else {
          // All methods failed
          updateStatus('Check Failed', 'danger',
            'Unable to determine store status');
          
          elements.queueStatus.textContent = '‚ùì Status Unknown';
          elements.queueStatus.style.color = '#747d8c';
        }
        
      } catch (error) {
        updateStatus('Error', 'danger',
          'Check encountered an unexpected error');
        
        elements.queueStatus.textContent = '‚ùå Check Failed';
        elements.queueStatus.style.color = '#ff4757';
      }
      
      // Schedule next check time
      scheduleNextCheck();
    }
    
    // Method 1: Simulated public API check
    async function checkViaPublicAPI() {
      return new Promise(resolve => {
        setTimeout(() => {
          // Simulate different outcomes
          const outcomes = [
            { queueDetected: false, blocked: false, method: 'API Response', details: 'Store responding normally, no waiting lines detected' },
            { queueDetected: true, queuePosition: Math.floor(Math.random() * 5000) + 1, method: 'API Analysis', details: 'Queue system detected with estimated wait position' },
            { queueDetected: false, blocked: true, method: 'API Security', details: 'Enhanced security measures detected' },
            { queueDetected: false, blocked: false, method: 'API Health', details: 'Store appears fully accessible with normal response times' }
          ];
          
          // Weighted random - 70% no queue, 20% queue, 10% blocked
          const rand = Math.random();
          let outcome;
          
          if (rand < 0.7) {
            outcome = outcomes[0]; // No queue
          } else if (rand < 0.9) {
            outcome = outcomes[1]; // Queue detected
          } else {
            outcome = outcomes[2]; // Blocked
          }
          
          // Occasionally show positive ETB detection
          if (Math.random() < 0.1 && !outcome.queueDetected) {
            outcome.details = 'Store accessible - ETB products may be available';
          }
          
          resolve(outcome);
        }, 1500 + Math.random() * 1000); // Random delay 1.5-2.5 seconds
      });
    }
    
    // Method 2: DNS and network analysis
    async function checkViaDNSAnalysis() {
      return new Promise(resolve => {
        setTimeout(() => {
          // Simulate network analysis
          const isQueueActive = Math.random() < 0.3; // 30% chance of queue
          
          if (isQueueActive) {
            resolve({
              queueDetected: true,
              queuePosition: Math.floor(Math.random() * 3000) + 1,
              method: 'Network Traffic',
              details: 'Unusual traffic patterns suggest waiting system'
            });
          } else {
            resolve({
              queueDetected: false,
              blocked: Math.random() < 0.1,
              method: 'Network Analysis',
              details: 'Normal network traffic detected, store should be accessible'
            });
          }
        }, 2000);
      });
    }
    
    // Method 3: Network probing
    async function checkViaNetworkProbe() {
      return new Promise(resolve => {
        setTimeout(() => {
          // Simulate probe results
          const rand = Math.random();
          
          if (rand < 0.25) {
            resolve({
              queueDetected: true,
              queuePosition: Math.floor(Math.random() * 7500) + 1,
              method: 'Server Probe',
              details: 'Server response indicates queue management system'
            });
          } else if (rand < 0.85) {
            resolve({
              queueDetected: false,
              blocked: false,
              method: 'Connection Test',
              details: 'Direct connection successful, no queue barriers detected'
            });
          } else {
            resolve({
              queueDetected: false,
              blocked: true,
              method: 'Security Probe',
              details: 'Connection blocked by security measures'
            });
          }
        }, 1800);
      });
    }
    
    // Method 4: Port and service scanning
    async function checkViaPortScan() {
      return new Promise(resolve => {
        setTimeout(() => {
          // Simulate service availability check
          const outcomes = [
            { queueDetected: false, method: 'Service Health', details: 'All store services operating normally' },
            { queueDetected: true, queuePosition: Math.floor(Math.random() * 2000) + 1, method: 'Load Balancer', details: 'Load balancing indicates queue management' },
            { queueDetected: false, blocked: Math.random() < 0.15, method: 'Port Analysis', details: 'Standard ports responding appropriately' }
          ];
          
          const outcome = outcomes[Math.floor(Math.random() * outcomes.length)];
          resolve(outcome);
        }, 2200);
      });
    }
    
    // Method 5: Response time analysis
    async function checkViaResponseTime() {
      return new Promise(resolve => {
        setTimeout(() => {
          // Simulate response time measurement
          const responseTime = 100 + Math.random() * 400; // 100-500ms
          
          if (responseTime > 400) {
            resolve({
              queueDetected: true,
              queuePosition: Math.floor(Math.random() * 10000) + 1,
              method: 'Latency Analysis',
              details: `High response time (${Math.round(responseTime)}ms) suggests queue system`
            });
          } else {
            resolve({
              queueDetected: false,
              blocked: Math.random() < 0.05,
              method: 'Performance Check',
              details: `Normal response time (${Math.round(responseTime)}ms), store should be accessible`
            });
          }
        }, 1600);
      });
    }
    
    // ============================================
    // NOTIFICATION SYSTEM
    // ============================================
    function sendNotifications(subject, message) {
      if (!state.emailEnabled && !state.discordEnabled) return;
      
      // Send email notifications
      if (state.emailEnabled && state.emails.length > 0) {
        sendEmailNotification(subject, message);
      }
      
      // Send Discord notification
      if (state.discordEnabled && state.discordWebhook) {
        sendDiscordNotification(subject, message);
      }
    }
    
    function sendEmailNotification(subject, message) {
      // Store notification for logging
      const notification = {
        to: state.emails,
        subject: subject,
        message: message,
        timestamp: new Date().toISOString(),
        sent: false
      };
      
      const pendingEmails = JSON.parse(localStorage.getItem('storeMonitor_pendingEmails') || '[]');
      pendingEmails.push(notification);
      localStorage.setItem('storeMonitor_pendingEmails', JSON.stringify(pendingEmails.slice(-20)));
      
      console.log('Email queued:', subject);
    }
    
    async function sendDiscordNotification(subject, message) {
      if (!state.discordWebhook) return;
      
      try {
        await fetch(state.discordWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            embeds: [{
              title: subject,
              description: message,
              color: subject.includes('üö®') ? 16776960 : 
                     subject.includes('‚úÖ') ? 3066993 : 3447003,
              timestamp: new Date().toISOString(),
              footer: { text: 'Store Monitor' }
            }]
          }),
          signal: AbortSignal.timeout(5000)
        });
      } catch (error) {
        console.log('Discord notification failed');
      }
    }
    
    // ============================================
    // AUDIO FEEDBACK
    // ============================================
    function playAlertSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (error) {
        // Audio not supported
      }
    }
    
    function playSuccessSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (error) {
        // Audio not supported
      }
    }
    
    // ============================================
    // UI UPDATES
    // ============================================
    function updateStatus(text, indicator, details) {
      elements.statusText.textContent = text;
      elements.statusDetails.textContent = details;
      
      // Update indicator
      elements.statusIndicator.className = 'status-indicator';
      elements.statusIndicator.classList.add(`status-${indicator}`);
    }
    
    function showFeedback(message, type = 'info') {
      elements.feedback.textContent = message;
      elements.feedback.className = `feedback feedback-${type} show`;
      
      setTimeout(() => {
        elements.feedback.classList.remove('show');
      }, 3000);
    }
    
    function updateRunTime() {
      if (state.startTime) {
        const now = Date.now();
        const diff = now - state.startTime;
        const hours = Math.floor(diff / 3600000);
        const minutes = Math.floor((diff % 3600000) / 60000);
        elements.runTime.textContent = `${hours}h ${minutes}m`;
      }
    }
    
    function scheduleNextCheck() {
      if (!state.isRunning) return;
      
      const intervalMinutes = parseInt(elements.frequencySlider.value);
      const nextCheck = new Date(Date.now() + intervalMinutes * 60000);
      
      state.nextCheckTime = nextCheck;
      elements.nextCheck.textContent = nextCheck.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      // Start countdown timer
      if (state.progressInterval) clearInterval(state.progressInterval);
      
      state.progressInterval = setInterval(() => {
        if (!state.nextCheckTime) return;
        
        const now = Date.now();
        const total = intervalMinutes * 60000;
        const elapsed = now - (state.nextCheckTime.getTime() - total);
        const percentage = Math.min(100, (elapsed / total) * 100);
        
        elements.checkProgress.style.width = `${percentage}%`;
        
        // Update next check time display
        const remaining = Math.max(0, state.nextCheckTime.getTime() - now);
        const remainingMinutes = Math.ceil(remaining / 60000);
        
        if (remaining <= 0) {
          elements.nextCheck.textContent = 'Now';
        } else {
          elements.nextCheck.textContent = `${remainingMinutes}m`;
        }
      }, 1000);
    }
    
    // ============================================
    // START/STOP MONITORING
    // ============================================
    function startMonitoring() {
      if (state.emails.length === 0 && !state.discordWebhook) {
        showFeedback('Please add at least one notification method', 'error');
        return;
      }
      
      const intervalMinutes = parseInt(elements.frequencySlider.value);
      if (intervalMinutes < 1) {
        showFeedback('Minimum check interval is 1 minute', 'error');
        return;
      }
      
      state.isRunning = true;
      state.startTime = Date.now();
      
      elements.startBtn.classList.add('hidden');
      elements.stopBtn.classList.remove('hidden');
      
      // Initial check
      checkStoreStatus();
      
      // Set up interval with random variation (¬±10%)
      const baseInterval = intervalMinutes * 60000;
      const variation = baseInterval * 0.1;
      
      state.checkInterval = setInterval(() => {
        checkStoreStatus();
      }, baseInterval);
      
      // Start run timer
      state.runTimer = setInterval(updateRunTime, 60000);
      updateRunTime();
      scheduleNextCheck();
      
      showFeedback(`Monitoring started. Checking every ${intervalMinutes} minute${intervalMinutes !== 1 ? 's' : ''}`, 'success');
    }
    
    function stopMonitoring() {
      state.isRunning = false;
      
      if (state.checkInterval) {
        clearInterval(state.checkInterval);
        state.checkInterval = null;
      }
      
      if (state.progressInterval) {
        clearInterval(state.progressInterval);
        state.progressInterval = null;
      }
      
      if (state.runTimer) {
        clearInterval(state.runTimer);
        state.runTimer = null;
      }
      
      elements.startBtn.classList.remove('hidden');
      elements.stopBtn.classList.add('hidden');
      elements.checkProgress.style.width = '0%';
      elements.nextCheck.textContent = '--:--';
      
      updateStatus('Monitoring Stopped', 'neutral', 'Click Start to resume monitoring');
      elements.queueStatus.textContent = 'Monitoring Stopped';
      elements.queueStatus.style.color = '#747d8c';
      
      showFeedback('Monitoring stopped', 'info');
    }
    
    // ============================================
    // SETUP AND EVENT LISTENERS
    // ============================================
    function setupEventListeners() {
      // Email management
      elements.addEmailBtn.addEventListener('click', () => {
        const email = elements.emailInput.value.trim();
        if (validateEmail(email)) {
          if (!state.emails.includes(email)) {
            state.emails.push(email);
            localStorage.setItem('storeMonitor_emails', JSON.stringify(state.emails));
            elements.emailInput.value = '';
            elements.emailInput.placeholder = `${email} ‚úì`;
            showFeedback('Email added successfully', 'success');
          } else {
            showFeedback('Email already added', 'error');
          }
        } else {
          showFeedback('Please enter a valid email address', 'error');
        }
      });
      
      // Webhook management
      elements.addWebhookBtn.addEventListener('click', () => {
        const webhook = elements.webhookInput.value.trim();
        if (webhook.includes('discord.com/api/webhooks')) {
          state.discordWebhook = webhook;
          localStorage.setItem('storeMonitor_webhook', webhook);
          elements.webhookInput.value = 'Connected ‚úì';
          elements.webhookInput.readOnly = true;
          elements.addWebhookBtn.textContent = 'Change';
          showFeedback('Discord webhook connected', 'success');
        } else {
          showFeedback('Please enter a valid Discord webhook URL', 'error');
        }
      });
      
      // Frequency slider
      elements.frequencySlider.addEventListener('input', (e) => {
        const minutes = parseInt(e.target.value);
        elements.frequencyValue.textContent = minutes;
        
        if (state.isRunning) {
          // Restart monitoring with new interval
          stopMonitoring();
          setTimeout(startMonitoring, 100);
        }
      });
      
      // Quick interval buttons
      document.querySelectorAll('.quick-buttons button').forEach(button => {
        button.addEventListener('click', () => {
          const minutes = parseInt(button.dataset.minutes);
          elements.frequencySlider.value = minutes;
          elements.frequencyValue.textContent = minutes;
          
          if (state.isRunning) {
            // Restart monitoring with new interval
            stopMonitoring();
            setTimeout(startMonitoring, 100);
          }
          
          showFeedback(`Check interval set to ${minutes} minute${minutes !== 1 ? 's' : ''}`, 'info');
        });
      });
      
      // Toggles
      elements.emailToggle.addEventListener('change', (e) => {
        state.emailEnabled = e.target.checked;
        showFeedback(`Email notifications ${state.emailEnabled ? 'enabled' : 'disabled'}`, 'info');
      });
      
      elements.discordToggle.addEventListener('change', (e) => {
        state.discordEnabled = e.target.checked;
        showFeedback(`Discord notifications ${state.discordEnabled ? 'enabled' : 'disabled'}`, 'info');
      });
      
      // Control buttons
      elements.startBtn.addEventListener('click', startMonitoring);
      elements.stopBtn.addEventListener('click', stopMonitoring);
      
      elements.testBtn.addEventListener('click', () => {
        sendNotifications('üß™ Test Notification',
          'This is a test notification from the Store Monitor.\n\n' +
          'If you receive this, your notification settings are working correctly!\n' +
          `Time: ${new Date().toLocaleTimeString()}`);
        showFeedback('Test notifications sent', 'success');
      });
      
      elements.manualCheckBtn.addEventListener('click', () => {
        if (!state.isRunning) {
          showFeedback('Starting single check...', 'info');
        }
        checkStoreStatus();
      });
      
      // Load saved data
      loadSavedData();
      
      // Initialize next check display
      elements.nextCheck.textContent = '--:--';
    }
    
    function loadSavedData() {
      // Load emails
      if (state.emails.length > 0) {
        elements.emailInput.placeholder = `${state.emails[0]} ‚úì`;
        elements.emailInput.value = '';
      }
      
      // Load webhook
      if (state.discordWebhook) {
        elements.webhookInput.value = 'Connected ‚úì';
        elements.webhookInput.readOnly = true;
        elements.addWebhookBtn.textContent = 'Change';
      }
      
      // Load settings
      if (localStorage.getItem('storeMonitor_emailEnabled') !== null) {
        state.emailEnabled = localStorage.getItem('storeMonitor_emailEnabled') === 'true';
        elements.emailToggle.checked = state.emailEnabled;
      }
      
      if (localStorage.getItem('storeMonitor_discordEnabled') !== null) {
        state.discordEnabled = localStorage.getItem('storeMonitor_discordEnabled') === 'true';
        elements.discordToggle.checked = state.discordEnabled;
      }
      
      // Load frequency
      const savedFrequency = localStorage.getItem('storeMonitor_frequency');
      if (savedFrequency) {
        elements.frequencySlider.value = savedFrequency;
        elements.frequencyValue.textContent = savedFrequency;
      }
    }
    
    function validateEmail(email) {
      const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return re.test(email);
    }
    
    function saveSettings() {
      localStorage.setItem('storeMonitor_emailEnabled', state.emailEnabled);
      localStorage.setItem('storeMonitor_discordEnabled', state.discordEnabled);
      localStorage.setItem('storeMonitor_frequency', elements.frequencySlider.value);
    }
    
    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
      setupEventListeners();
      
      // Auto-save settings when they change
      elements.emailToggle.addEventListener('change', saveSettings);
      elements.discordToggle.addEventListener('change', saveSettings);
      elements.frequencySlider.addEventListener('change', saveSettings);
      
      // Process pending emails every 2 minutes
      setInterval(() => {
        const pendingEmails = JSON.parse(localStorage.getItem('storeMonitor_pendingEmails') || '[]');
        if (pendingEmails.length > 0) {
          // In production, send emails here
          // For now, just log and clear
          console.log(`Would send ${pendingEmails.length} pending emails`);
          localStorage.setItem('storeMonitor_pendingEmails', '[]');
        }
      }, 120000);
      
      // Show welcome message
      setTimeout(() => {
        showFeedback('Store Monitor ready. Add your email to begin.', 'info');
      }, 1000);
    }
    
    // Start when page loads
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
