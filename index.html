<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PokeDrop Master - Ultimate Pok√©mon Center Drop Hunter</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Nunito', sans-serif;
      background: linear-gradient(135deg, #87CEEB 0%, #98D8E8 25%, #90EE90 50%, #ADD8E6 75%, #FFB6C1 100%);
      background-size: 400% 400%;
      animation: skyShift 20s ease infinite;
      position: relative;
      overflow-x: hidden;
      min-height: 100vh;
    }
    @keyframes skyShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    .poke-sky { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
    .floating-poke { position: absolute; opacity: 0.7; animation: float 6s ease-in-out infinite; }
    .pikachu { top: 10%; left: 5%; width: 80px; animation-delay: 0s; }
    .umbreon { top: 20%; right: 5%; width: 100px; animation-delay: 2s; }
    .snorlax { bottom: 10%; left: 10%; width: 120px; animation: snore 4s ease-in-out infinite; }
    @keyframes float { 0%, 100% { transform: translateY(0px) rotate(0deg); } 50% { transform: translateY(-20px) rotate(10deg); } }
    @keyframes snore { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .pokeball-float { position: absolute; width: 30px; height: 30px; background: url('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png') no-repeat; background-size: contain; opacity: 0.5; animation: spin 3s linear infinite; z-index: 1; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .main-card {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 25px;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      max-width: 400px;
      margin: 2rem auto;
      position: relative;
      z-index: 10;
      border: 2px solid #FF6B6B;
      animation: evolveIn 1s ease-out;
    }
    @keyframes evolveIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    .status-pokedex { background: linear-gradient(145deg, #FF9A56, #FF6B6B); color: white; padding: 1rem; border-radius: 15px; margin: 1rem 0; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    button { background: linear-gradient(145deg, #4ECDC4, #44A08D); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 50px; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.2); margin: 0.5rem 0; }
    button:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
    button:disabled { background: #CCC; transform: none; cursor: not-allowed; }
    input, select { border: 2px solid #4ECDC4; border-radius: 10px; padding: 0.5rem; width: 100%; margin: 0.5rem 0; }
    input[type="range"]::-webkit-slider-thumb { background: #FF6B6B; border-radius: 50%; }
    .alert-zap { animation: zap 0.5s ease; }
    @keyframes zap { 0%, 100% { border-color: #FFD700; box-shadow: 0 0 20px #FFD700; } 50% { border-color: #FF6B6B; box-shadow: 0 0 30px #FF6B6B; } }
    .hidden { display: none; }
    @media (max-width: 480px) { .main-card { margin: 1rem; padding: 1rem; } .floating-poke { width: 50px; } }
  </style>
</head>
<body>
  <div class="poke-sky">
    <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png" class="floating-poke pikachu" alt="Pikachu">
    <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/197.png" class="floating-poke umbreon" alt="Umbreon">
    <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/143.png" class="floating-poke snorlax" alt="Snorlax">
    <div class="pokeball-float" style="top: 30%; left: 80%;"></div>
    <div class="pokeball-float" style="top: 60%; right: 20%; animation-delay: 1s;"></div>
  </div>

  <div class="main-card">
    <h1 style="text-align: center; color: #FF6B6B; font-size: 1.8rem; margin-bottom: 1rem;">üåÄ PokeDrop Master</h1>
    <p style="text-align: center; color: #666; margin-bottom: 1rem;">Hunt drops like a pro trainer! Monitors new releases, queues, & auto-joins lines.</p>

    <!-- Firebase Sign-In & Email Section -->
    <button id="signInBtn" onclick="signInAnonymously()" style="background: #4CAF50;">Sign In Anonymously</button>
    <div id="emailSection" class="hidden">
      <label>Your Email for Alerts:</label>
      <input type="email" id="emailInput" placeholder="user@example.com">
      <button onclick="subscribeEmail(document.getElementById('emailInput').value)">Subscribe</button>
      <button onclick="testEmail()">Test Email</button>
    </div>

    <!-- Discord Setup -->
    <label>Discord Webhook URL (for alerts):</label>
    <input type="url" id="discordWebhook" placeholder="https://discord.com/api/webhooks/...">
    <button onclick="testDiscord()">Test Discord Ping</button>

    <!-- Options -->
    <label>Check every: <span id="freqVal">5</span> mins</label>
    <input type="range" id="freqSlider" min="1" max="30" value="5">
    <label>Alert after: <span id="threshVal">2</span> fails</label>
    <input type="range" id="threshSlider" min="1" max="5" value="2">
    <label>Specific Product URL (optional):</label>
    <input type="url" id="specificUrl" placeholder="https://www.pokemoncenter.com/product/...">

    <!-- Status Pok√©dex -->
    <div id="status" class="status-pokedex">
      <p><strong>Status:</strong> <span id="statusText">Ready to evolve!</span></p>
      <p>Last Check: <span id="lastCheck">Never</span></p>
      <p>Runtime: <span id="runtime">0m 0s</span></p>
      <p>Consec Fails: <span id="consec">0</span></p>
      <p>New Products: <span id="newCount">0</span></p>
      <p>Details: <span id="details">Waiting for your command...</span></p>
    </div>

    <button id="startBtn" onclick="startMonitoring()">üöÄ Start Hunt</button>
    <button id="stopBtn" class="hidden" onclick="stopMonitoring()">‚èπÔ∏è Stop Hunt</button>
  </div>

  <!-- Audio for Cries -->
  <audio id="pikacry" preload="auto">
    <source src="https://raw.githubusercontent.com/PokeAPI/audio/master/cries/2021/25.mp3" type="audio/mpeg">
  </audio>

  <!-- Firebase SDKs -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js';
    import { getAnalytics } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-analytics.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js';
    import { getFirestore, collection, doc, setDoc, getDocs, getDoc, query } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyCAXDkAaED4PqSW3lgpXwPMbOHnoq-5ybo",
      authDomain: "pokemoncentermail.firebaseapp.com",
      projectId: "pokemoncentermail",
      storageBucket: "pokemoncentermail.firebasestorage.app",
      messagingSenderId: "823572131347",
      appId: "1:823572131347:web:13db2feafe741d5e5459e6",
      measurementId: "G-M55TXWL2YQ"
    };

    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;

    window.signInAnonymously = async () => {
      try {
        const result = await signInAnonymously(auth);
        currentUser = result.user;
        console.log('Signed in as:', currentUser.uid);
        alert('Signed in! Add your email to subscribe.');
        document.getElementById('signInBtn').classList.add('hidden');
        document.getElementById('emailSection').classList.remove('hidden');
      } catch (error) {
        console.error('Sign-in error:', error.message, error.code);
        alert('Sign-in failed: ' + error.message);
      }
    };

    onAuthStateChanged(auth, (user) => {
      currentUser = user;
      if (user) {
        console.log('User state changed: Signed in');
        loadSubscription();
      } else {
        console.log('User state changed: Signed out');
        document.getElementById('signInBtn').classList.remove('hidden');
        document.getElementById('emailSection').classList.add('hidden');
      }
    });

    window.subscribeEmail = async (email) => {
      if (!currentUser) return alert('Sign in first!');
      if (!email || !/\S+@\S+\.\S+/.test(email)) return alert('Enter a valid email!');
      try {
        // Check if email already exists in Firestore
        const q = query(collection(db, 'subscribers'));
        const querySnapshot = await getDocs(q);
        const existingEmails = querySnapshot.docs.map(d => d.data().email);
        if (existingEmails.includes(email)) {
          alert('Email already subscribed!');
          return;
        }
        await setDoc(doc(db, 'subscribers', currentUser.uid), {
          email: email,
          subscribed: true,
          timestamp: new Date()
        });
        let localEmails = JSON.parse(localStorage.getItem('pokedrop_emails') || '[]');
        if (!localEmails.includes(email)) localEmails.push(email);
        localStorage.setItem('pokedrop_emails', JSON.stringify([...new Set(localEmails)]));
        alert('Subscribed! You\'ll get alerts on drops.');
        console.log('Subscribed:', email);
      } catch (error) {
        console.error('Subscription error:', error.message, error.code);
        alert('Subscription failed: ' + error.message);
      }
    };

    async function loadSubscription() {
      try {
        const docSnap = await getDoc(doc(db, 'subscribers', currentUser.uid));
        if (docSnap.exists()) {
          const data = docSnap.data();
          document.getElementById('emailInput').value = data.email;
          console.log('Loaded subscription:', data.email);
        }
      } catch (error) {
        console.error('Load subscription error:', error.message, error.code);
      }
    }

    window.getAllSubscribers = async () => {
      try {
        const q = query(collection(db, 'subscribers'));
        const querySnapshot = await getDocs(q);
        const emails = [...new Set(querySnapshot.docs.map(d => d.data().email).filter(email => email))];
        console.log('Fetched subscribers:', emails);
        return emails;
      } catch (error) {
        console.error('Query error:', error.message, error.code);
        alert('Failed to fetch subscribers: ' + error.message + ' (Using local emails as fallback)');
        return [...new Set(JSON.parse(localStorage.getItem('pokedrop_emails') || '[]'))];
      }
    };
  </script>

  <script>
    let intervalId = null, startTime = null, consecFails = 0, failThresh = 2, checkFreq = 5 * 60 * 1000;
    let lastProducts = JSON.parse(localStorage.getItem('last_products') || '[]');
    let proxies = ['https://corsproxy.io/?', 'https://api.allorigins.win/get?url=', 'https://thingproxy.freeboard.io/fetch/', 'https://cors-anywhere.herokuapp.com/', 'https://api.codetabs.com/v1/proxy?quest='];
    let blacklisted = new Set();
    let webhookUrl = '';
    let isHunting = false;
    let localEmails = JSON.parse(localStorage.getItem('pokedrop_emails') || '[]');

    async function sendEmailViaSendGrid(toEmails, subject, body) {
      const apiKey = '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';
      const sendGridUrl = 'https://api.sendgrid.com/v3/mail/send';
      // Deduplicate emails
      const uniqueEmails = [...new Set(toEmails)];
      try {
        const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(sendGridUrl)}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            personalizations: [{ to: uniqueEmails.map(email => ({ email })) }],
            from: { email: 'kronborgnielsen@gmail.com' },
            subject: subject,
            content: [{ type: 'text/plain', value: body }]
          })
        });
        if (response.ok) {
          console.log('Emails sent via SendGrid:', uniqueEmails);
        } else {
          const errorText = await response.text();
          throw new Error(`SendGrid API error: ${response.status} - ${errorText}`);
        }
      } catch (error) {
        console.error('SendGrid error:', error.message);
        alert('SendGrid failed, using mailto fallback: ' + error.message);
        const bcc = uniqueEmails.join(',');
        window.location.href = `mailto:?bcc=${encodeURIComponent(bcc)}&subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      }
    }

    async function testEmail() {
      try {
        let allEmails = await getAllSubscribers();
        if (allEmails.length === 0) allEmails = localEmails;
        if (allEmails.length === 0) return alert('No subscribers yet! Add an email first.');
        const testMsg = 'üß™ Test Alert from PokeDrop Master! Everything is wired up.';
        await sendEmailViaSendGrid(allEmails, 'Test Alert', testMsg);
        alert(`Test email sent to ${allEmails.length} recipient(s)! Check inboxes.`);
      } catch (error) {
        console.error('Test email error:', error.message);
        alert('Test failed: ' + error.message);
      }
    }

    async function sendDiscord(title, desc, color = 0xFFD700) {
      webhookUrl = document.getElementById('discordWebhook').value;
      if (!webhookUrl) return;
      const embed = { title, description: desc, color, footer: { text: `PokeDrop Master | ${new Date().toLocaleString()}` } };
      try {
        await fetch(webhookUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ embeds: [embed] }) });
      } catch (e) { console.error('Discord fail:', e.message); }
    }

    async function testDiscord() {
      try {
        await sendDiscord('üß™ Test Ping', 'Your webhook is live! Ready for drops. ‚ö°');
        alert('Test sent! Check your Discord.');
      } catch (e) {
        console.error('Discord test error:', e.message);
        alert('Discord test failed: ' + e.message);
      }
    }

    function playCry() {
      const audio = document.getElementById('pikacry');
      audio.play().catch(() => new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+Dyvmwh').play());
    }

    async function getHealthyProxy(url) {
      for (let p of proxies.filter(pr => !blacklisted.has(pr))) {
        try {
          const ctrl = new AbortController();
          setTimeout(() => ctrl.abort(), 5000);
          const res = await fetch(`${p}${encodeURIComponent(url)}`, { signal: ctrl.signal });
          if (res.ok) return p;
        } catch (e) { console.error('Proxy failed:', p, e.message); }
        blacklisted.add(p);
        setTimeout(() => blacklisted.delete(p), 300000);
      }
      console.warn('No healthy proxies found');
      return null;
    }

    function extractQueue(text, url) {
      const posMatch = text.match(/pos["']?\s*[:=]\s*["']?(\d+)["']?/i) || url.match(/pos=(\d+)/i);
      return posMatch ? posMatch[1] : null;
    }

    function extractProducts(text) {
      const productMatches = [...text.matchAll(/<a[^>]*href=["']([^"']*product[^"']*)["'][^>]*>([^<]+)<\/a>/gi)];
      return productMatches.map(m => ({ url: m[1], title: m[2].trim() })).slice(0, 20);
    }

    function detectNewProducts(currentProds) {
      const newOnes = currentProds.filter(p => !lastProducts.some(lp => lp.title === p.title && lp.url === p.url));
      const count = newOnes.length;
      if (count > 0) {
        lastProducts = currentProds;
        localStorage.setItem('last_products', JSON.stringify(lastProducts));
      }
      return { count, new: newOnes };
    }

    async function checkSite(isConsec = false) {
      const specific = document.getElementById('specificUrl').value || '';
      const urls = specific ? [specific] : ['https://www.pokemoncenter.com/', 'https://www.pokemoncenter.com/category/new-releases', 'https://www.pokemoncenter.com/category/trading-card-game'];
      let success = false, queuePos = null, products = [], details = '';

      for (let url of urls) {
        const proxy = await getHealthyProxy(url);
        if (!proxy) continue;
        try {
          let res = await fetch(`${proxy}${encodeURIComponent(url)}`, { headers: { 'User-Agent': 'Mozilla/5.0' } });
          if (res.ok) {
            let text = proxy.includes('allorigins') ? (await res.json()).contents : await res.text();
            const finalUrl = decodeURIComponent(res.url.replace(proxy, ''));
            queuePos = extractQueue(text, finalUrl);
            if (queuePos || /queue-it\.net/i.test(finalUrl) || /waiting room/i.test(text)) {
              details = `Queue detected! Pos: ${queuePos || 'Unknown'}. Joining line...`;
              if (!isConsec) window.location.href = 'https://www.pokemoncenter.com/';
              success = false;
              break;
            } else if (/pokemoncenter.com/i.test(finalUrl) && text.length > 2000) {
              products = extractProducts(text);
              const { count, new: newProds } = detectNewProducts(products);
              details = count > 0 ? `DROP DETECTED! ${count} new product(s): ${newProds.map(np => np.title).join(', ')}` : 'Store running normal, no new drops.';
              success = true;
              if (count > 0) playCry();
              break;
            }
          }
        } catch (e) { console.error('Check error:', e.message); }
      }

      if (!success && !queuePos) details = 'Check failed (proxies down?).';
      updateUI(success ? (products.length > 0 ? 'Drop Alert! üèÜ' : 'Store Running Normal - Nothing to Hunt') : 'Queued/Closed üö´', details, detectNewProducts(products).count, success);
      logCheck(success ? 'Success' : 'Fail', details, queuePos);

      if (success && detectNewProducts(products).count > 0 || queuePos) {
        const alertMsg = details;
        sendDiscord('üö® PokeDrop Alert!', alertMsg);
        sendEmailViaSendGrid(await getAllSubscribers(), 'PokeDrop Alert!', alertMsg);
      }

      return { success, queuePos, isFail: !success };
    }

    async function verifyConsec(count = 1) {
      if (count >= failThresh) {
        const result = await checkSite(true);
        if (!result.isFail) consecFails = 0;
        else {
          await new Promise(r => setTimeout(r, 5000));
          await verifyConsec(count + 1);
        }
      }
    }

    async function startMonitoring() {
      try {
        document.getElementById('startBtn').disabled = true;
        let hasNotifs = localEmails.length > 0 || (await getAllSubscribers()).length > 0 || document.getElementById('discordWebhook').value;
        if (!hasNotifs) {
          alert('Add a Discord webhook or email to enable notifications!');
          document.getElementById('startBtn').disabled = false;
          return;
        }
        isHunting = true;
        consecFails = 0;
        startTime = Date.now();
        await checkSite();
        intervalId = setInterval(async () => {
          await checkSite();
          if (consecFails++ >= failThresh) await verifyConsec();
        }, checkFreq + Math.random() * 60000 - 30000);
        document.getElementById('startBtn').classList.add('hidden');
        document.getElementById('stopBtn').classList.remove('hidden');
        updateUI('Hunting... üïµÔ∏è');
      } catch (error) {
        console.error('Start monitoring error:', error.message);
        alert('Failed to start: ' + error.message);
        document.getElementById('startBtn').disabled = false;
      }
    }

    function stopMonitoring() {
      clearInterval(intervalId);
      intervalId = null;
      startTime = null;
      consecFails = 0;
      isHunting = false;
      document.getElementById('startBtn').classList.remove('hidden');
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').classList.add('hidden');
      updateUI('Hunt Paused üõë');
    }

    document.getElementById('freqSlider').oninput = e => {
      checkFreq = e.target.value * 60 * 1000;
      document.getElementById('freqVal').textContent = e.target.value;
      localStorage.setItem('freq', e.target.value);
    };
    document.getElementById('threshSlider').oninput = e => {
      failThresh = e.target.value;
      document.getElementById('threshVal').textContent = e.target.value;
      localStorage.setItem('thresh', e.target.value);
    };

    function logCheck(status, details, queue) {
      console.log(`${new Date().toISOString()}: ${status} - ${details} (Queue: ${queue})`);
    }

    document.getElementById('freqSlider').value = localStorage.getItem('freq') || 5;
    document.getElementById('freqVal').textContent = document.getElementById('freqSlider').value;
    document.getElementById('threshSlider').value = localStorage.getItem('thresh') || 2;
    document.getElementById('threshVal').textContent = document.getElementById('threshSlider').value;
  </script>
</body>
</html>
