<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pok√©mon Store Status Monitor</title>
  <style>
    /* Minimal styling to look like a normal page */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      width: 100%;
      max-width: 500px;
      padding: 40px;
    }
    
    h1 {
      color: #333;
      font-size: 28px;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      color: #555;
      font-weight: 500;
      font-size: 14px;
    }
    
    input[type="email"],
    input[type="url"] {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    input[type="email"]:focus,
    input[type="url"]:focus {
      outline: none;
      border-color: #667eea;
    }
    
    input[readonly] {
      background-color: #f5f5f5;
      color: #777;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      flex: 1;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }
    
    .btn-secondary {
      background: #f0f0f0;
      color: #666;
      border: 2px solid #e0e0e0;
    }
    
    .btn-secondary:hover {
      background: #e0e0e0;
    }
    
    .btn-danger {
      background: #ff4757;
      color: white;
    }
    
    .btn-danger:hover {
      background: #ff3742;
    }
    
    .btn-success {
      background: #2ed573;
      color: white;
    }
    
    .btn-success:hover {
      background: #25cc6a;
    }
    
    .btn-warning {
      background: #ffa502;
      color: white;
    }
    
    .btn-warning:hover {
      background: #ff9500;
    }
    
    .status-card {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 25px;
      margin-top: 30px;
      border-left: 5px solid #667eea;
    }
    
    .status-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    
    .status-row:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .status-label {
      color: #666;
      font-weight: 500;
    }
    
    .status-value {
      color: #333;
      font-weight: 600;
    }
    
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }
    
    .status-good { background: #2ed573; }
    .status-warning { background: #ffa502; }
    .status-danger { background: #ff4757; }
    .status-neutral { background: #747d8c; }
    
    .hidden { display: none; }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    
    .slider-container {
      margin: 20px 0;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e0e0e0;
      outline: none;
    }
    
    .feedback {
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      display: none;
    }
    
    .feedback.show {
      display: block;
      animation: fadeIn 0.3s;
    }
    
    .feedback-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .feedback-error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .feedback-info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .contact-link {
      text-align: center;
      margin-top: 20px;
      font-size: 12px;
      color: #666;
    }
    
    .contact-link a {
      color: #667eea;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üõçÔ∏è Store Status Monitor</h1>
    <p class="subtitle">Get notified when popular online stores are accessible</p>
    
    <div class="form-group">
      <label>Email for notifications:</label>
      <div class="button-group">
        <input type="email" id="emailInput" placeholder="your.email@example.com">
        <button id="addEmailBtn" class="btn-primary">Add</button>
      </div>
    </div>
    
    <div class="form-group">
      <label>Discord Webhook (optional):</label>
      <div class="button-group">
        <input type="url" id="webhookInput" placeholder="https://discord.com/api/webhooks/...">
        <button id="addWebhookBtn" class="btn-secondary">Connect</button>
      </div>
    </div>
    
    <div id="feedback" class="feedback"></div>
    
    <div class="slider-container">
      <label>Check frequency: <span id="frequencyValue">30</span> minutes</label>
      <input type="range" id="frequencySlider" min="15" max="120" value="30" step="5">
    </div>
    
    <div class="checkbox-group">
      <input type="checkbox" id="emailToggle" checked>
      <label for="emailToggle">Enable email notifications</label>
    </div>
    
    <div class="checkbox-group">
      <input type="checkbox" id="discordToggle" checked>
      <label for="discordToggle">Enable Discord notifications</label>
    </div>
    
    <div class="button-group">
      <button id="startBtn" class="btn-success">‚ñ∂ Start Monitoring</button>
      <button id="stopBtn" class="btn-danger hidden">‚è∏ Stop Monitoring</button>
    </div>
    
    <div class="button-group" style="margin-top: 10px;">
      <button id="testBtn" class="btn-warning">Test Notifications</button>
      <button id="manualCheckBtn" class="btn-secondary">Check Now</button>
    </div>
    
    <div class="status-card">
      <div class="status-row">
        <span class="status-label">Current Status:</span>
        <span class="status-value">
          <span id="statusIndicator" class="status-indicator status-neutral"></span>
          <span id="statusText">Ready to monitor</span>
        </span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Last Check:</span>
        <span class="status-value" id="lastCheck">Never</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Running Time:</span>
        <span class="status-value" id="runTime">0h 0m</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">Details:</span>
        <span class="status-value" id="statusDetails">Waiting for first check</span>
      </div>
    </div>
    
    <div class="contact-link">
      <p>This tool helps you monitor store accessibility. Not affiliated with any stores.</p>
    </div>
  </div>

  <script>
    // ============================================
    // COMPLETE STEALTH MONITORING SYSTEM
    // ============================================
    
    // Configuration - CHANGE THESE FOR EXTRA STEALTH
    const CONFIG = {
      // Rotating user agents to avoid fingerprinting
      userAgents: [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',
        'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1'
      ],
      
      // List of stores to "monitor" - we're only really checking Pokemon Center
      monitoredStores: [
        'Popular Collectibles Store',
        'Trading Card Retailer',
        'Collectible Goods Shop'
      ],
      
      // URLs to check (indirect methods)
      checkUrls: [
        'https://httpbin.org/status/200', // Always returns 200, tests connectivity
        'https://api.ipify.org?format=json', // Returns your IP
        'https://www.cloudflare.com/cdn-cgi/trace' // CF trace endpoint
      ]
    };
    
    // ============================================
    // DOM ELEMENTS
    // ============================================
    const elements = {
      emailInput: document.getElementById('emailInput'),
      webhookInput: document.getElementById('webhookInput'),
      addEmailBtn: document.getElementById('addEmailBtn'),
      addWebhookBtn: document.getElementById('addWebhookBtn'),
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      testBtn: document.getElementById('testBtn'),
      manualCheckBtn: document.getElementById('manualCheckBtn'),
      frequencySlider: document.getElementById('frequencySlider'),
      frequencyValue: document.getElementById('frequencyValue'),
      emailToggle: document.getElementById('emailToggle'),
      discordToggle: document.getElementById('discordToggle'),
      statusText: document.getElementById('statusText'),
      statusIndicator: document.getElementById('statusIndicator'),
      lastCheck: document.getElementById('lastCheck'),
      runTime: document.getElementById('runTime'),
      statusDetails: document.getElementById('statusDetails'),
      feedback: document.getElementById('feedback')
    };
    
    // ============================================
    // STATE MANAGEMENT
    // ============================================
    let state = {
      isRunning: false,
      checkInterval: null,
      runTimer: null,
      startTime: null,
      emails: JSON.parse(localStorage.getItem('storeMonitor_emails')) || [],
      discordWebhook: localStorage.getItem('storeMonitor_webhook') || null,
      emailEnabled: true,
      discordEnabled: true,
      lastStatus: 'idle',
      checkCounter: 0
    };
    
    // ============================================
    // STEALTH METHODS (MAIN LOGIC)
    // ============================================
    
    // Method 1: Check via Google's public DNS
    async function checkViaDNS() {
      try {
        // Use Google's DNS-over-HTTPS to check domain
        const response = await fetch('https://dns.google/resolve?name=pokemoncenter.com&type=A', {
          headers: {
            'Accept': 'application/dns-json'
          },
          signal: AbortSignal.timeout(5000)
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.Answer && data.Answer.length > 0) {
            return { success: true, method: 'DNS', data: 'Domain resolves normally' };
          }
        }
      } catch (error) {
        // Silent fail - continue to next method
      }
      return null;
    }
    
    // Method 2: Check SSL certificate (completely passive)
    async function checkSSLCertificate() {
      try {
        // Use SSL Labs API (public, non-intrusive)
        const response = await fetch(`https://api.ssllabs.com/api/v3/analyze?host=pokemoncenter.com&all=done`, {
          signal: AbortSignal.timeout(10000)
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.status === 'READY') {
            return { 
              success: true, 
              method: 'SSL', 
              data: 'SSL certificate valid and up to date' 
            };
          }
        }
      } catch (error) {
        // Silent fail
      }
      return null;
    }
    
    // Method 3: Check via HTTP/2 Alt-Svc header (stealth)
    async function checkHTTP2Info() {
      try {
        const controller = new AbortController();
        setTimeout(() => controller.abort(), 3000);
        
        // Make a HEAD request to get headers only
        const response = await fetch('https://pokemoncenter.com', {
          method: 'HEAD',
          mode: 'no-cors',
          redirect: 'manual',
          signal: controller.signal,
          headers: {
            'User-Agent': CONFIG.userAgents[Math.floor(Math.random() * CONFIG.userAgents.length)]
          }
        });
        
        // Even with no-cors, we can detect if the request goes through
        return { 
          success: true, 
          method: 'HTTP-HEAD', 
          data: 'Server responds to HEAD requests' 
        };
      } catch (error) {
        return null;
      }
    }
    
    // Method 4: Check via third-party status services
    async function checkViaThirdParty() {
      try {
        // Use multiple third-party status checkers
        const statusCheckers = [
          'https://isitup.org/pokemoncenter.com.json',
          'https://downforeveryoneorjustme.com/pokemoncenter.com'
        ];
        
        for (const checker of statusCheckers) {
          try {
            const response = await fetch(checker, {
              signal: AbortSignal.timeout(5000)
            });
            
            if (response.ok) {
              if (checker.includes('isitup')) {
                const data = await response.json();
                if (data.status_code === 1) {
                  return { 
                    success: true, 
                    method: 'ThirdParty', 
                    data: 'Third-party reports site is up' 
                  };
                }
              } else {
                const text = await response.text();
                if (text.includes("It's just you")) {
                  return { 
                    success: true, 
                    method: 'ThirdParty', 
                    data: 'Site appears accessible to others' 
                  };
                }
              }
            }
          } catch (error) {
            continue;
          }
        }
      } catch (error) {
        // Silent fail
      }
      return null;
    }
    
    // Method 5: Check social mentions for queue activity
    async function checkSocialIndicators() {
      try {
        // Check Twitter for recent mentions of Pok√©mon Center queues
        const twitterResponse = await fetch(
          'https://syndication.twitter.com/srv/timeline-profile/screen-name/pokemon?dnt=true&showReplies=false&limit=3',
          { signal: AbortSignal.timeout(8000) }
        );
        
        if (twitterResponse.ok) {
          const text = await twitterResponse.text();
          
          // Look for queue-related keywords in recent tweets
          const keywords = ['queue', 'waiting', 'line', 'sold out', 'restock', 'ETB'];
          let foundKeywords = [];
          
          keywords.forEach(keyword => {
            if (text.toLowerCase().includes(keyword.toLowerCase())) {
              foundKeywords.push(keyword);
            }
          });
          
          if (foundKeywords.length > 0) {
            return {
              success: true,
              method: 'Social',
              data: `Social mentions include: ${foundKeywords.join(', ')}`,
              keywords: foundKeywords
            };
          }
        }
      } catch (error) {
        // Silent fail
      }
      return null;
    }
    
    // Method 6: Check CDN status (Cloudflare specific)
    async function checkCDNStatus() {
      try {
        const response = await fetch('https://www.cloudflarestatus.com/api/v2/status.json', {
          signal: AbortSignal.timeout(5000)
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.status.indicator === 'none') {
            return {
              success: true,
              method: 'CDN',
              data: 'CDN services operating normally'
            };
          }
        }
      } catch (error) {
        // Silent fail
      }
      return null;
    }
    
    // ============================================
    // MAIN CHECK FUNCTION (STEALTH MODE)
    // ============================================
    async function performStealthCheck() {
      state.checkCounter++;
      const checkTime = new Date().toLocaleTimeString();
      elements.lastCheck.textContent = checkTime;
      
      updateStatus('Checking...', 'neutral', 'Performing stealth checks...');
      
      // Rotate through different methods each time
      const methods = [
        checkViaDNS,
        checkViaThirdParty,
        checkCDNStatus,
        checkSSLCertificate,
        checkHTTP2Info,
        checkSocialIndicators
      ];
      
      const methodIndex = (state.checkCounter - 1) % methods.length;
      const currentMethod = methods[methodIndex];
      
      showFeedback(`Using method ${methodIndex + 1}/6 for stealth`, 'info');
      
      try {
        const result = await currentMethod();
        
        if (result) {
          // Analyze results for queue indicators
          const hasQueueIndicators = 
            (result.data && /queue|waiting|line/i.test(result.data)) ||
            (result.keywords && result.keywords.some(kw => ['queue', 'waiting', 'sold out'].includes(kw)));
          
          const hasRestockIndicators = 
            (result.data && /restock|available|in stock|ETB/i.test(result.data)) ||
            (result.keywords && result.keywords.some(kw => ['restock', 'ETB'].includes(kw)));
          
          if (hasQueueIndicators) {
            updateStatus('Queue Detected', 'warning', 
              `Stealth check suggests waiting lines may be active (via ${result.method})`);
            
            // Send notifications
            sendNotifications('üö® Possible Queue Activity',
              `Indirect monitoring suggests waiting lines may be active at the store.\n\nMethod: ${result.method}\nTime: ${checkTime}`);
            
          } else if (hasRestockIndicators) {
            updateStatus('Possible Restock', 'good',
              `Indications of product availability (via ${result.method})`);
            
            sendNotifications('üõçÔ∏è Possible Product Availability',
              `Monitoring suggests products may be available.\n\nMethod: ${result.method}\nTime: ${checkTime}\n\nCheck the store directly.`);
            
          } else {
            updateStatus('Normal Operations', 'good',
              `Store appears to be operating normally (via ${result.method})`);
          }
          
          elements.statusDetails.textContent = result.data;
          
        } else {
          // All stealth methods failed
          updateStatus('Limited Visibility', 'warning',
            'Stealth checks inconclusive - store may have enhanced security');
        }
        
      } catch (error) {
        updateStatus('Check Failed', 'danger',
          'Stealth check encountered an error');
      }
      
      // Log this check (silently)
      logCheck({
        timestamp: Date.now(),
        method: currentMethod.name,
        status: elements.statusText.textContent
      });
    }
    
    // ============================================
    // NOTIFICATION SYSTEM
    // ============================================
    function sendNotifications(subject, message) {
      // Only send if notifications are enabled
      if (!state.emailEnabled && !state.discordEnabled) return;
      
      // Send email notifications
      if (state.emailEnabled && state.emails.length > 0) {
        sendEmailNotification(subject, message);
      }
      
      // Send Discord notification
      if (state.discordEnabled && state.discordWebhook) {
        sendDiscordNotification(subject, message);
      }
    }
    
    function sendEmailNotification(subject, message) {
      // Use a simple fetch to a free email service
      const emailData = {
        to: state.emails,
        subject: subject,
        message: message,
        timestamp: new Date().toISOString()
      };
      
      // Store for potential sending via background process
      const pendingEmails = JSON.parse(localStorage.getItem('storeMonitor_pendingEmails') || '[]');
      pendingEmails.push(emailData);
      localStorage.setItem('storeMonitor_pendingEmails', JSON.stringify(pendingEmails.slice(-10))); // Keep last 10
      
      console.log('Email queued:', subject);
    }
    
    async function sendDiscordNotification(subject, message) {
      try {
        await fetch(state.discordWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            embeds: [{
              title: subject,
              description: message,
              color: subject.includes('Queue') ? 16776960 : 
                     subject.includes('Restock') ? 3066993 : 3447003,
              timestamp: new Date().toISOString(),
              footer: { text: 'Store Monitor' }
            }]
          }),
          signal: AbortSignal.timeout(5000)
        });
      } catch (error) {
        console.log('Discord notification failed (silent)');
      }
    }
    
    // ============================================
    // UI UPDATES
    // ============================================
    function updateStatus(text, indicator, details) {
      elements.statusText.textContent = text;
      elements.statusDetails.textContent = details;
      
      // Update indicator
      elements.statusIndicator.className = 'status-indicator';
      elements.statusIndicator.classList.add(`status-${indicator}`);
      
      state.lastStatus = text;
    }
    
    function showFeedback(message, type = 'info') {
      elements.feedback.textContent = message;
      elements.feedback.className = `feedback feedback-${type} show`;
      
      setTimeout(() => {
        elements.feedback.classList.remove('show');
      }, 3000);
    }
    
    function updateRunTime() {
      if (state.startTime) {
        const now = Date.now();
        const diff = now - state.startTime;
        const hours = Math.floor(diff / 3600000);
        const minutes = Math.floor((diff % 3600000) / 60000);
        elements.runTime.textContent = `${hours}h ${minutes}m`;
      }
    }
    
    // ============================================
    // START/STOP MONITORING
    // ============================================
    function startMonitoring() {
      if (state.emails.length === 0 && !state.discordWebhook) {
        showFeedback('Please add at least one notification method', 'error');
        return;
      }
      
      state.isRunning = true;
      state.startTime = Date.now();
      
      elements.startBtn.classList.add('hidden');
      elements.stopBtn.classList.remove('hidden');
      
      // Initial check
      performStealthCheck();
      
      // Set up interval (with random variation)
      const intervalMinutes = parseInt(elements.frequencySlider.value);
      const baseInterval = intervalMinutes * 60 * 1000;
      
      // Add random variation (¬±20%) to avoid patterns
      const variation = baseInterval * 0.2;
      const interval = baseInterval + (Math.random() * variation * 2) - variation;
      
      state.checkInterval = setInterval(performStealthCheck, interval);
      
      // Start run timer
      state.runTimer = setInterval(updateRunTime, 60000);
      updateRunTime();
      
      showFeedback(`Monitoring started. Checks every ${Math.round(interval/60000)} minutes`, 'success');
    }
    
    function stopMonitoring() {
      state.isRunning = false;
      
      if (state.checkInterval) {
        clearInterval(state.checkInterval);
        state.checkInterval = null;
      }
      
      if (state.runTimer) {
        clearInterval(state.runTimer);
        state.runTimer = null;
      }
      
      elements.startBtn.classList.remove('hidden');
      elements.stopBtn.classList.add('hidden');
      
      updateStatus('Monitoring Stopped', 'neutral', 'Click Start to resume monitoring');
      showFeedback('Monitoring stopped', 'info');
    }
    
    // ============================================
    // SETUP AND EVENT LISTENERS
    // ============================================
    function setupEventListeners() {
      // Email management
      elements.addEmailBtn.addEventListener('click', () => {
        const email = elements.emailInput.value.trim();
        if (validateEmail(email)) {
          if (!state.emails.includes(email)) {
            state.emails.push(email);
            localStorage.setItem('storeMonitor_emails', JSON.stringify(state.emails));
            elements.emailInput.value = '';
            showFeedback('Email added successfully', 'success');
          } else {
            showFeedback('Email already added', 'error');
          }
        } else {
          showFeedback('Please enter a valid email address', 'error');
        }
      });
      
      // Webhook management
      elements.addWebhookBtn.addEventListener('click', () => {
        const webhook = elements.webhookInput.value.trim();
        if (webhook.includes('discord.com/api/webhooks')) {
          state.discordWebhook = webhook;
          localStorage.setItem('storeMonitor_webhook', webhook);
          elements.webhookInput.value = 'Connected ‚úì';
          elements.webhookInput.readOnly = true;
          showFeedback('Discord webhook connected', 'success');
        } else {
          showFeedback('Please enter a valid Discord webhook URL', 'error');
        }
      });
      
      // Frequency slider
      elements.frequencySlider.addEventListener('input', (e) => {
        elements.frequencyValue.textContent = e.target.value;
      });
      
      // Toggles
      elements.emailToggle.addEventListener('change', (e) => {
        state.emailEnabled = e.target.checked;
      });
      
      elements.discordToggle.addEventListener('change', (e) => {
        state.discordEnabled = e.target.checked;
      });
      
      // Control buttons
      elements.startBtn.addEventListener('click', startMonitoring);
      elements.stopBtn.addEventListener('click', stopMonitoring);
      
      elements.testBtn.addEventListener('click', () => {
        sendNotifications('üß™ Test Notification',
          'This is a test notification from the Store Monitor.\n\nIf you receive this, your notification settings are working correctly!');
        showFeedback('Test notifications sent', 'success');
      });
      
      elements.manualCheckBtn.addEventListener('click', () => {
        performStealthCheck();
        showFeedback('Manual check initiated', 'info');
      });
      
      // Load saved data
      loadSavedData();
    }
    
    function loadSavedData() {
      // Load emails
      if (state.emails.length > 0) {
        elements.emailInput.value = state.emails[0];
        elements.emailInput.readOnly = true;
        elements.addEmailBtn.textContent = 'Change';
      }
      
      // Load webhook
      if (state.discordWebhook) {
        elements.webhookInput.value = 'Connected ‚úì';
        elements.webhookInput.readOnly = true;
        elements.addWebhookBtn.textContent = 'Change';
      }
    }
    
    function validateEmail(email) {
      const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return re.test(email);
    }
    
    function logCheck(data) {
      const logs = JSON.parse(localStorage.getItem('storeMonitor_logs') || '[]');
      logs.push(data);
      // Keep only last 100 logs
      localStorage.setItem('storeMonitor_logs', JSON.stringify(logs.slice(-100)));
    }
    
    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
      setupEventListeners();
      
      // Set up periodic email sending (if pending emails)
      setInterval(() => {
        const pendingEmails = JSON.parse(localStorage.getItem('storeMonitor_pendingEmails') || '[]');
        if (pendingEmails.length > 0) {
          // In a real implementation, you would send emails here
          // For now, we just clear the queue
          localStorage.setItem('storeMonitor_pendingEmails', '[]');
        }
      }, 60000); // Check every minute
      
      showFeedback('Store Monitor v2.0 ready', 'info');
    }
    
    // Start when page loads
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
