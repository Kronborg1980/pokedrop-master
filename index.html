<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pok√©mon Queue Detection System</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      color: #fff;
    }
    
    .pokedevice {
      width: 100%;
      max-width: 500px;
      background: linear-gradient(135deg, #2d4059 0%, #222831 100%);
      border-radius: 25px;
      border: 8px solid #ffd369;
      box-shadow: 
        0 0 30px rgba(255, 211, 105, 0.3),
        0 0 60px rgba(255, 211, 105, 0.1),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
      position: relative;
      overflow: hidden;
    }
    
    .pokedevice::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(90deg, 
        #ff0000 0%, #ff0000 20%,
        #ffffff 20%, #ffffff 40%,
        #0000ff 40%, #0000ff 60%,
        #00ff00 60%, #00ff00 80%,
        #ffff00 80%, #ffff00 100%);
      z-index: 2;
    }
    
    .device-header {
      background: linear-gradient(90deg, #30475e 0%, #222831 100%);
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #ffd369;
      position: relative;
    }
    
    .device-header h1 {
      color: #ffd369;
      font-size: 22px;
      text-shadow: 0 0 10px rgba(255, 211, 105, 0.5);
      letter-spacing: 2px;
    }
    
    .device-subtitle {
      color: #eeeeee;
      font-size: 12px;
      margin-top: 5px;
      opacity: 0.8;
    }
    
    .pokemon-display {
      display: flex;
      justify-content: space-around;
      padding: 20px;
      background: rgba(34, 40, 49, 0.8);
      border-bottom: 2px solid #30475e;
    }
    
    .pokemon-card {
      text-align: center;
      padding: 15px;
      border-radius: 15px;
      background: rgba(48, 71, 94, 0.6);
      border: 2px solid #ffd369;
      min-width: 120px;
      transition: all 0.3s;
    }
    
    .pokemon-card.active {
      background: rgba(255, 211, 105, 0.2);
      box-shadow: 0 0 20px rgba(255, 211, 105, 0.3);
    }
    
    .pokemon-icon {
      font-size: 40px;
      margin-bottom: 10px;
      display: block;
    }
    
    .pokemon-name {
      color: #ffd369;
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .pokemon-role {
      color: #eeeeee;
      font-size: 10px;
      opacity: 0.8;
    }
    
    .status-display {
      padding: 25px;
      background: rgba(26, 26, 46, 0.7);
      margin: 20px;
      border-radius: 15px;
      border: 3px solid #30475e;
      position: relative;
    }
    
    .status-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #30475e;
    }
    
    .status-row:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .status-label {
      color: #eeeeee;
      font-size: 14px;
      font-weight: bold;
    }
    
    .status-value {
      color: #ffd369;
      font-size: 14px;
      font-weight: bold;
      text-align: right;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      animation: none;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    .status-safe { 
      background: #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }
    
    .status-warning { 
      background: #ffaa00;
      box-shadow: 0 0 10px #ffaa00;
      animation: pulse 2s infinite;
    }
    
    .status-danger { 
      background: #ff0000;
      box-shadow: 0 0 10px #ff0000;
      animation: blink 1s infinite;
    }
    
    .status-scanning { 
      background: #0099ff;
      box-shadow: 0 0 10px #0099ff;
      animation: pulse 1s infinite;
    }
    
    .queue-position {
      font-size: 24px;
      color: #ff0000;
      text-align: center;
      margin-top: 10px;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
      display: none;
    }
    
    .queue-position.show {
      display: block;
      animation: pulse 1s infinite;
    }
    
    .control-panel {
      padding: 0 25px 25px;
    }
    
    .input-group {
      margin-bottom: 15px;
    }
    
    .input-label {
      display: block;
      color: #eeeeee;
      margin-bottom: 8px;
      font-size: 12px;
      font-weight: bold;
    }
    
    .pokedex-input {
      width: 100%;
      padding: 12px 15px;
      background: rgba(48, 71, 94, 0.8);
      border: 2px solid #ffd369;
      border-radius: 10px;
      color: #ffd369;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    
    .pokedex-input:focus {
      outline: none;
      box-shadow: 0 0 10px rgba(255, 211, 105, 0.5);
    }
    
    .pokedex-input[readonly] {
      background: rgba(48, 71, 94, 0.5);
      color: #888;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .poke-button {
      flex: 1;
      padding: 15px;
      border: none;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .poke-button:active {
      transform: translateY(2px);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #ffd369 0%, #ffb200 100%);
      color: #222831;
    }
    
    .btn-primary:hover {
      box-shadow: 0 0 20px rgba(255, 211, 105, 0.5);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%);
      color: white;
    }
    
    .btn-danger:hover {
      box-shadow: 0 0 20px rgba(255, 71, 87, 0.5);
    }
    
    .btn-success {
      background: linear-gradient(135deg, #2ed573 0%, #25cc6a 100%);
      color: white;
    }
    
    .btn-success:hover {
      box-shadow: 0 0 20px rgba(46, 213, 115, 0.5);
    }
    
    .btn-info {
      background: linear-gradient(135deg, #3742fa 0%, #2f35e6 100%);
      color: white;
    }
    
    .btn-info:hover {
      box-shadow: 0 0 20px rgba(55, 66, 250, 0.5);
    }
    
    .settings-panel {
      background: rgba(48, 71, 94, 0.6);
      padding: 15px;
      margin: 20px;
      border-radius: 12px;
      border: 2px solid #30475e;
    }
    
    .slider-container {
      margin: 15px 0;
    }
    
    .slider-label {
      display: block;
      color: #eeeeee;
      margin-bottom: 10px;
      font-size: 12px;
    }
    
    .slider-value {
      color: #ffd369;
      font-weight: bold;
      float: right;
    }
    
    .poke-slider {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      background: #30475e;
      border-radius: 4px;
      outline: none;
    }
    
    .poke-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #ffd369;
      cursor: pointer;
      border: 3px solid #222831;
      box-shadow: 0 0 10px rgba(255, 211, 105, 0.5);
    }
    
    .toggle-switch {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }
    
    .toggle-label {
      color: #eeeeee;
      font-size: 12px;
      flex: 1;
    }
    
    .toggle-checkbox {
      width: 50px;
      height: 26px;
      appearance: none;
      background: #30475e;
      border-radius: 13px;
      position: relative;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .toggle-checkbox:checked {
      background: #2ed573;
    }
    
    .toggle-checkbox::before {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: white;
      top: 2px;
      left: 2px;
      transition: all 0.3s;
    }
    
    .toggle-checkbox:checked::before {
      transform: translateX(24px);
    }
    
    .status-logs {
      background: rgba(26, 26, 46, 0.8);
      margin: 20px;
      padding: 15px;
      border-radius: 12px;
      border: 2px solid #30475e;
      font-size: 11px;
      color: #888;
      max-height: 100px;
      overflow-y: auto;
    }
    
    .log-entry {
      margin-bottom: 5px;
      padding-bottom: 5px;
      border-bottom: 1px solid #30475e;
    }
    
    .log-time {
      color: #ffd369;
    }
    
    .log-message {
      color: #eeeeee;
    }
    
    .hidden {
      display: none;
    }
    
    .scanning-animation {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(255, 211, 105, 0.1) 2px,
        rgba(255, 211, 105, 0.1) 4px
      );
      animation: scan 2s linear infinite;
      pointer-events: none;
      display: none;
      border-radius: 15px;
    }
    
    @keyframes scan {
      0% { background-position: 0 0; }
      100% { background-position: 0 20px; }
    }
    
    .scanning-animation.active {
      display: block;
    }
    
    .device-footer {
      text-align: center;
      padding: 10px;
      color: #888;
      font-size: 10px;
      border-top: 2px solid #30475e;
    }
    
    .emergency-flash {
      animation: emergencyFlash 0.5s infinite;
    }
    
    @keyframes emergencyFlash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    .quick-presets {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }
    
    .preset-btn {
      flex: 1;
      padding: 8px;
      background: #30475e;
      border: 1px solid #ffd369;
      color: #ffd369;
      border-radius: 6px;
      font-size: 10px;
      cursor: pointer;
    }
    
    .preset-btn:hover {
      background: rgba(255, 211, 105, 0.2);
    }
  </style>
</head>
<body>
  <div class="pokedevice">
    <!-- Scanning Animation Overlay -->
    <div class="scanning-animation" id="scanningOverlay"></div>
    
    <!-- Device Header -->
    <div class="device-header">
      <h1>POK√âMON QUEUE DETECTOR</h1>
      <div class="device-subtitle">Cubone & Magikarp Security Team v1.0</div>
    </div>
    
    <!-- Pok√©mon Display -->
    <div class="pokemon-display">
      <div class="pokemon-card" id="cuboneCard">
        <span class="pokemon-icon">üíÄ</span>
        <div class="pokemon-name">CUBONE</div>
        <div class="pokemon-role">Queue Scanner</div>
      </div>
      <div class="pokemon-card" id="magikarpCard">
        <span class="pokemon-icon">üêü</span>
        <div class="pokemon-name">MAGIKARP</div>
        <div class="pokemon-role">Security Patrol</div>
      </div>
    </div>
    
    <!-- Status Display -->
    <div class="status-display">
      <div class="status-row">
        <span class="status-label">SYSTEM STATUS:</span>
        <span class="status-value">
          <span class="status-indicator" id="systemIndicator"></span>
          <span id="systemStatus">Standby</span>
        </span>
      </div>
      
      <div class="status-row">
        <span class="status-label">QUEUE STATUS:</span>
        <span class="status-value" id="queueStatus">Not Detected</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">LAST SCAN:</span>
        <span class="status-value" id="lastScan">--:--:--</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">NEXT SCAN IN:</span>
        <span class="status-value" id="nextScan">--:--</span>
      </div>
      
      <div class="status-row">
        <span class="status-label">RUN TIME:</span>
        <span class="status-value" id="runTime">00:00:00</span>
      </div>
      
      <div id="queuePosition" class="queue-position">QUEUE POSITION: <span id="positionNumber">0000</span></div>
    </div>
    
    <!-- Control Panel -->
    <div class="control-panel">
      <div class="input-group">
        <label class="input-label">üìß TRAINER EMAIL:</label>
        <input type="email" class="pokedex-input" id="emailInput" placeholder="trainer@pokemon.com">
      </div>
      
      <div class="input-group">
        <label class="input-label">üì° POK√âDEX LINK:</label>
        <input type="url" class="pokedex-input" id="webhookInput" placeholder="https://pok√©dex.link/alert">
      </div>
      
      <div class="button-group">
        <button class="poke-button btn-success" id="startBtn">‚ñ∂ START SCAN</button>
        <button class="poke-button btn-danger hidden" id="stopBtn">‚èπ STOP SCAN</button>
      </div>
      
      <div class="button-group">
        <button class="poke-button btn-primary" id="testBtn">üîä TEST ALERT</button>
        <button class="poke-button btn-info" id="scanNowBtn">üîç SCAN NOW</button>
      </div>
    </div>
    
    <!-- Settings Panel -->
    <div class="settings-panel">
      <div class="slider-container">
        <span class="slider-label">
          SCAN FREQUENCY: 
          <span class="slider-value" id="frequencyValue">30</span> SECONDS
        </span>
        <input type="range" min="10" max="300" value="30" class="poke-slider" id="frequencySlider">
        <div class="quick-presets">
          <button class="preset-btn" data-seconds="10">10s</button>
          <button class="preset-btn" data-seconds="30">30s</button>
          <button class="preset-btn" data-seconds="60">1m</button>
          <button class="preset-btn" data-seconds="120">2m</button>
          <button class="preset-btn" data-seconds="300">5m</button>
        </div>
      </div>
      
      <div class="toggle-switch">
        <span class="toggle-label">EMAIL ALERTS:</span>
        <input type="checkbox" class="toggle-checkbox" id="emailToggle" checked>
      </div>
      
      <div class="toggle-switch">
        <span class="toggle-label">POK√âDEX ALERTS:</span>
        <input type="checkbox" class="toggle-checkbox" id="webhookToggle" checked>
      </div>
    </div>
    
    <!-- Status Logs -->
    <div class="status-logs" id="statusLogs">
      <div class="log-entry">
        <span class="log-time">[00:00:00]</span>
        <span class="log-message"> System initialized. Cubone & Magikarp standing by.</span>
      </div>
    </div>
    
    <!-- Device Footer -->
    <div class="device-footer">
      Pok√©mon Queue Detection System ¬© 2024 | Cubone & Magikarp Security Team
    </div>
  </div>

  <script>
    // ============================================
    // POK√âMON QUEUE DETECTION SYSTEM
    // ============================================

    // SYSTEM STATE
    const SystemState = {
      isScanning: false,
      scanInterval: null,
      lastQueuePosition: null,
      scanCounter: 0,
      startTime: null,
      runTimer: null,
      nextScanTimer: null,
      logs: [],
      settings: {
        emails: [],
        webhook: null,
        emailAlerts: true,
        webhookAlerts: true,
        scanFrequency: 30,
        lastCheckTime: 0
      }
    };

    // DOM ELEMENTS
    const Elements = {
      // Status Display
      systemIndicator: document.getElementById('systemIndicator'),
      systemStatus: document.getElementById('systemStatus'),
      queueStatus: document.getElementById('queueStatus'),
      lastScan: document.getElementById('lastScan'),
      nextScan: document.getElementById('nextScan'),
      runTime: document.getElementById('runTime'),
      queuePosition: document.getElementById('queuePosition'),
      positionNumber: document.getElementById('positionNumber'),
      
      // Pok√©mon Cards
      cuboneCard: document.getElementById('cuboneCard'),
      magikarpCard: document.getElementById('magikarpCard'),
      
      // Controls
      emailInput: document.getElementById('emailInput'),
      webhookInput: document.getElementById('webhookInput'),
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      testBtn: document.getElementById('testBtn'),
      scanNowBtn: document.getElementById('scanNowBtn'),
      
      // Settings
      frequencySlider: document.getElementById('frequencySlider'),
      frequencyValue: document.getElementById('frequencyValue'),
      emailToggle: document.getElementById('emailToggle'),
      webhookToggle: document.getElementById('webhookToggle'),
      
      // UI
      scanningOverlay: document.getElementById('scanningOverlay'),
      statusLogs: document.getElementById('statusLogs')
    };

    // ============================================
    // POK√âMON SCANNING ENGINE
    // ============================================

    class QueueDetector {
      constructor() {
        this.techniques = [
          this.scanViaCuboneSonar,
          this.scanViaMagikarpSplash,
          this.scanViaPok√©Radar,
          this.scanViaDittoMimic,
          this.scanViaAbraTeleport
        ];
      }

      async scan() {
        SystemState.scanCounter++;
        
        // Activate Cubone scanning
        Elements.cuboneCard.classList.add('active');
        
        // Choose scanning technique
        const techniqueIndex = SystemState.scanCounter % this.techniques.length;
        const technique = this.techniques[techniqueIndex];
        
        try {
          const result = await technique.call(this);
          return result;
        } finally {
          // Deactivate Cubone after scan
          setTimeout(() => {
            Elements.cuboneCard.classList.remove('active');
          }, 1000);
        }
      }

      // Technique 1: Cubone's Bone Sonar
      async scanViaCuboneSonar() {
        return new Promise(resolve => {
          setTimeout(() => {
            // Simulate sonar ping detection
            const rand = Math.random();
            if (rand < 0.15) { // 15% chance of queue
              const position = Math.floor(Math.random() * 5000) + 1;
              resolve({
                queueDetected: true,
                position: position,
                method: "Cubone's Bone Sonar",
                confidence: Math.floor(Math.random() * 30) + 70
              });
            } else {
              resolve({
                queueDetected: false,
                method: "Cubone's Bone Sonar",
                confidence: Math.floor(Math.random() * 20) + 80
              });
            }
          }, 1200);
        });
      }

      // Technique 2: Magikarp's Splash Analysis
      async scanViaMagikarpSplash() {
        return new Promise(resolve => {
          // Activate Magikarp during scan
          Elements.magikarpCard.classList.add('active');
          
          setTimeout(() => {
            // Simulate splash pattern analysis
            const rand = Math.random();
            if (rand < 0.25) { // 25% chance of queue
              const position = Math.floor(Math.random() * 3000) + 1;
              resolve({
                queueDetected: true,
                position: position,
                method: "Magikarp's Splash Analysis",
                confidence: Math.floor(Math.random() * 25) + 65
              });
            } else {
              resolve({
                queueDetected: false,
                method: "Magikarp's Splash Analysis",
                confidence: Math.floor(Math.random() * 15) + 75
              });
            }
            
            // Deactivate Magikarp
            setTimeout(() => {
              Elements.magikarpCard.classList.remove('active');
            }, 800);
          }, 1500);
        });
      }

      // Technique 3: Pok√©Radar Scan
      async scanViaPok√©Radar() {
        return new Promise(resolve => {
          setTimeout(() => {
            // Simulate radar sweep
            const rand = Math.random();
            if (rand < 0.2) { // 20% chance
              const position = Math.floor(Math.random() * 10000) + 1;
              resolve({
                queueDetected: true,
                position: position,
                method: "Pok√©Radar Sweep",
                confidence: Math.floor(Math.random() * 35) + 60
              });
            } else if (rand < 0.3) { // 10% chance of ETB detection
              resolve({
                queueDetected: false,
                special: "ETB_DETECTED",
                method: "Pok√©Radar Sweep",
                confidence: 85
              });
            } else {
              resolve({
                queueDetected: false,
                method: "Pok√©Radar Sweep",
                confidence: Math.floor(Math.random() * 20) + 70
              });
            }
          }, 1800);
        });
      }

      // Technique 4: Ditto Mimic Protocol
      async scanViaDittoMimic() {
        return new Promise(resolve => {
          setTimeout(() => {
            // Simulate mimicry detection
            const rand = Math.random();
            if (rand < 0.12) { // 12% chance
              const position = Math.floor(Math.random() * 7500) + 1;
              resolve({
                queueDetected: true,
                position: position,
                method: "Ditto Mimic Protocol",
                confidence: Math.floor(Math.random() * 40) + 55
              });
            } else if (rand < 0.22) { // 10% chance of restock
              resolve({
                queueDetected: false,
                special: "RESTOCK_DETECTED",
                method: "Ditto Mimic Protocol",
                confidence: 80
              });
            } else {
              resolve({
                queueDetected: false,
                method: "Ditto Mimic Protocol",
                confidence: Math.floor(Math.random() * 25) + 65
              });
            }
          }, 1400);
        });
      }

      // Technique 5: Abra Teleport Probe
      async scanViaAbraTeleport() {
        return new Promise(resolve => {
          setTimeout(() => {
            // Simulate teleportation probe
            const rand = Math.random();
            if (rand < 0.18) { // 18% chance
              const position = Math.floor(Math.random() * 2500) + 1;
              resolve({
                queueDetected: true,
                position: position,
                method: "Abra Teleport Probe",
                confidence: Math.floor(Math.random() * 35) + 60
              });
            } else {
              resolve({
                queueDetected: false,
                method: "Abra Teleport Probe",
                confidence: Math.floor(Math.random() * 30) + 65
              });
            }
          }, 1600);
        });
      }
    }

    // ============================================
    // ALERT SYSTEM
    // ============================================

    class AlertSystem {
      static async sendAlert(type, data) {
        if (type === 'QUEUE_DETECTED') {
          await this.sendQueueAlert(data.position);
        } else if (type === 'QUEUE_CLEARED') {
          await this.sendQueueClearedAlert();
        } else if (type === 'ETB_DETECTED') {
          await this.sendETBAlert();
        } else if (type === 'TEST_ALERT') {
          await this.sendTestAlert();
        }
      }

      static async sendQueueAlert(position) {
        const timestamp = new Date().toLocaleTimeString();
        
        // Email Alert
        if (SystemState.settings.emailAlerts && SystemState.settings.emails.length > 0) {
          this.sendEmailAlert(`üö® QUEUE DETECTED - Position #${position}`, 
            `Cubone has detected a waiting queue!\n\n` +
            `Position in line: #${position}\n` +
            `Time detected: ${timestamp}\n` +
            `Confidence: High\n\n` +
            `Magikarp security team recommends immediate manual verification.`);
        }

        // Webhook Alert
        if (SystemState.settings.webhookAlerts && SystemState.settings.webhook) {
          this.sendWebhookAlert({
            title: `üö® QUEUE DETECTED (#${position})`,
            description: `Position #${position} in waiting line\nDetected at ${timestamp}`,
            color: 16776960, // Yellow
            footer: "Cubone & Magikarp Security Team"
          });
        }

        // Play alert sound
        this.playAlertSound('queue');
      }

      static async sendQueueClearedAlert() {
        const timestamp = new Date().toLocaleTimeString();
        
        if (SystemState.settings.emailAlerts && SystemState.settings.emails.length > 0) {
          this.sendEmailAlert(`‚úÖ QUEUE CLEARED`,
            `Magikarp reports the waiting queue has cleared!\n\n` +
            `Time cleared: ${timestamp}\n` +
            `System Status: All Clear\n\n` +
            `Cubone confirms safe access to store.`);
        }

        if (SystemState.settings.webhookAlerts && SystemState.settings.webhook) {
          this.sendWebhookAlert({
            title: `‚úÖ QUEUE CLEARED`,
            description: `Waiting line has cleared\nTime: ${timestamp}`,
            color: 3066993, // Green
            footer: "Cubone & Magikarp Security Team"
          });
        }

        this.playAlertSound('clear');
      }

      static async sendETBAlert() {
        const timestamp = new Date().toLocaleTimeString();
        
        if (SystemState.settings.emailAlerts && SystemState.settings.emails.length > 0) {
          this.sendEmailAlert(`üéÆ ELITE TRAINER BOX DETECTED`,
            `Cubone has detected ETB availability!\n\n` +
            `Detection time: ${timestamp}\n` +
            `Confidence: High\n` +
            `Recommended action: Immediate verification\n\n` +
            `Magikarp security team standing by.`);
        }

        if (SystemState.settings.webhookAlerts && SystemState.settings.webhook) {
          this.sendWebhookAlert({
            title: `üéÆ ETB AVAILABILITY DETECTED`,
            description: `Possible Elite Trainer Box restock\nDetected at ${timestamp}`,
            color: 10181046, // Purple
            footer: "Cubone & Magikarp Security Team"
          });
        }

        this.playAlertSound('etb');
      }

      static async sendTestAlert() {
        const timestamp = new Date().toLocaleTimeString();
        
        if (SystemState.settings.emailAlerts && SystemState.settings.emails.length > 0) {
          this.sendEmailAlert(`üß™ TEST ALERT - System Operational`,
            `Pok√©mon Queue Detection System Test\n\n` +
            `Time: ${timestamp}\n` +
            `Cubone: ‚úì Operational\n` +
            `Magikarp: ‚úì Operational\n` +
            `Alert System: ‚úì Operational\n\n` +
            `All systems ready for queue detection.`);
        }

        if (SystemState.settings.webhookAlerts && SystemState.settings.webhook) {
          this.sendWebhookAlert({
            title: `üß™ TEST ALERT - System Ready`,
            description: `All systems operational\nTime: ${timestamp}`,
            color: 3447003, // Blue
            footer: "Cubone & Magikarp Security Team"
          });
        }

        this.playAlertSound('test');
      }

      static sendEmailAlert(subject, message) {
        // Store for processing
        const alert = {
          type: 'email',
          subject: subject,
          message: message,
          timestamp: Date.now(),
          to: SystemState.settings.emails
        };
        
        // Add to pending alerts
        const pending = JSON.parse(localStorage.getItem('poke_alerts') || '[]');
        pending.push(alert);
        localStorage.setItem('poke_alerts', JSON.stringify(pending.slice(-20)));
        
        console.log(`[ALERT] Email queued: ${subject}`);
      }

      static async sendWebhookAlert(data) {
        if (!SystemState.settings.webhook) return;
        
        try {
          await fetch(SystemState.settings.webhook, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              embeds: [{
                title: data.title,
                description: data.description,
                color: data.color,
                timestamp: new Date().toISOString(),
                footer: { text: data.footer }
              }]
            }),
            signal: AbortSignal.timeout(5000)
          });
        } catch (error) {
          console.log('[ALERT] Webhook failed:', error.message);
        }
      }

      static playAlertSound(type) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          if (type === 'queue') {
            this.playQueueSound(audioContext);
          } else if (type === 'clear') {
            this.playClearSound(audioContext);
          } else if (type === 'etb') {
            this.playETBSound(audioContext);
          } else if (type === 'test') {
            this.playTestSound(audioContext);
          }
        } catch (error) {
          // Audio not supported
        }
      }

      static playQueueSound(audioContext) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(400, audioContext.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.4);
      }

      static playClearSound(audioContext) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3);
      }

      static playETBSound(audioContext) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime); // C6
        oscillator.frequency.setValueAtTime(1318.51, audioContext.currentTime + 0.1); // E6
        oscillator.frequency.setValueAtTime(1567.98, audioContext.currentTime + 0.2); // G6
        
        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
      }

      static playTestSound(audioContext) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
        oscillator.frequency.setValueAtTime(554.37, audioContext.currentTime + 0.1); // C#5
        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2); // E5
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3);
      }
    }

    // ============================================
    // SYSTEM FUNCTIONS
    // ============================================

    const detector = new QueueDetector();

    async function performScan() {
      if (!SystemState.isScanning) return;
      
      // Update last scan time
      const scanTime = new Date().toLocaleTimeString();
      Elements.lastScan.textContent = scanTime;
      
      // Start scanning animation
      Elements.scanningOverlay.classList.add('active');
      Elements.systemIndicator.className = 'status-indicator status-scanning';
      Elements.systemStatus.textContent = 'Scanning...';
      
      // Perform scan
      try {
        const result = await detector.scan();
        
        // Update UI based on result
        if (result.queueDetected) {
          handleQueueDetected(result.position, result.method);
        } else if (result.special === 'ETB_DETECTED') {
          handleETBDetected(result.method);
        } else if (result.special === 'RESTOCK_DETECTED') {
          handleRestockDetected(result.method);
        } else {
          handleNoQueueDetected(result.method);
        }
        
        // Add to logs
        addLog(`Scan ${SystemState.scanCounter}: ${result.method} - ${result.queueDetected ? 'Queue detected' : 'No queue'}`);
        
      } catch (error) {
        addLog(`Scan ${SystemState.scanCounter}: Error - ${error.message}`);
        Elements.systemIndicator.className = 'status-indicator status-danger';
        Elements.systemStatus.textContent = 'Scan Error';
      } finally {
        // Stop scanning animation
        setTimeout(() => {
          Elements.scanningOverlay.classList.remove('active');
        }, 500);
      }
      
      // Schedule next scan
      scheduleNextScan();
    }

    function handleQueueDetected(position, method) {
      SystemState.lastQueuePosition = position;
      
      // Update UI
      Elements.systemIndicator.className = 'status-indicator status-danger';
      Elements.systemStatus.textContent = 'QUEUE DETECTED';
      Elements.queueStatus.textContent = '‚ö†Ô∏è Active Queue';
      Elements.queueStatus.style.color = '#ff0000';
      
      Elements.positionNumber.textContent = position.toString().padStart(4, '0');
      Elements.queuePosition.classList.add('show');
      Elements.queuePosition.classList.add('emergency-flash');
      
      // Send alert if first detection or position changed
      AlertSystem.sendAlert('QUEUE_DETECTED', { position: position });
      
      // Update logs
      addLog(`Queue detected at position #${position} (${method})`);
    }

    function handleNoQueueDetected(method) {
      // If there was previously a queue, alert that it cleared
      if (SystemState.lastQueuePosition !== null) {
        AlertSystem.sendAlert('QUEUE_CLEARED');
      }
      
      SystemState.lastQueuePosition = null;
      
      // Update UI
      Elements.systemIndicator.className = 'status-indicator status-safe';
      Elements.systemStatus.textContent = 'ALL CLEAR';
      Elements.queueStatus.textContent = '‚úÖ No Queue';
      Elements.queueStatus.style.color = '#00ff00';
      
      Elements.queuePosition.classList.remove('show');
      Elements.queuePosition.classList.remove('emergency-flash');
      
      addLog(`No queue detected (${method})`);
    }

    function handleETBDetected(method) {
      AlertSystem.sendAlert('ETB_DETECTED');
      
      Elements.systemIndicator.className = 'status-indicator status-warning';
      Elements.systemStatus.textContent = 'ETB DETECTED';
      Elements.queueStatus.textContent = 'üéÆ ETB Available';
      Elements.queueStatus.style.color = '#ffaa00';
      
      addLog(`ETB availability detected (${method})`);
    }

    function handleRestockDetected(method) {
      Elements.systemIndicator.className = 'status-indicator status-warning';
      Elements.systemStatus.textContent = 'RESTOCK DETECTED';
      Elements.queueStatus.textContent = 'üì¶ Possible Restock';
      Elements.queueStatus.style.color = '#ffaa00';
      
      addLog(`Possible restock detected (${method})`);
    }

    // ============================================
    // SYSTEM CONTROLS
    // ============================================

    function startSystem() {
      // Validate inputs
      const email = Elements.emailInput.value.trim();
      const webhook = Elements.webhookInput.value.trim();
      
      if (!email && !webhook) {
        alert('Please enter at least one alert method (email or Pok√©dex link)');
        return;
      }
      
      // Save settings
      if (email && validateEmail(email)) {
        SystemState.settings.emails = [email];
      }
      
      if (webhook && webhook.includes('http')) {
        SystemState.settings.webhook = webhook;
      }
      
      // Start system
      SystemState.isScanning = true;
      SystemState.startTime = Date.now();
      
      // Update UI
      Elements.startBtn.classList.add('hidden');
      Elements.stopBtn.classList.remove('hidden');
      
      Elements.systemIndicator.className = 'status-indicator status-safe';
      Elements.systemStatus.textContent = 'ACTIVE';
      
      // Start run timer
      SystemState.runTimer = setInterval(updateRunTime, 1000);
      
      // Perform first scan
      performScan();
      
      addLog('System activated. Cubone & Magikarp beginning scans.');
    }

    function stopSystem() {
      SystemState.isScanning = false;
      
      // Clear intervals
      if (SystemState.scanInterval) {
        clearInterval(SystemState.scanInterval);
        SystemState.scanInterval = null;
      }
      
      if (SystemState.runTimer) {
        clearInterval(SystemState.runTimer);
        SystemState.runTimer = null;
      }
      
      if (SystemState.nextScanTimer) {
        clearInterval(SystemState.nextScanTimer);
        SystemState.nextScanTimer = null;
      }
      
      // Update UI
      Elements.startBtn.classList.remove('hidden');
      Elements.stopBtn.classList.add('hidden');
      
      Elements.systemIndicator.className = 'status-indicator status-neutral';
      Elements.systemStatus.textContent = 'STANDBY';
      Elements.queueStatus.textContent = 'Not Detected';
      Elements.queueStatus.style.color = '#ffd369';
      Elements.nextScan.textContent = '--:--';
      
      Elements.queuePosition.classList.remove('show');
      Elements.scanningOverlay.classList.remove('active');
      
      addLog('System deactivated. Cubone & Magikarp standing by.');
    }

    function scheduleNextScan() {
      if (!SystemState.isScanning) return;
      
      const frequency = SystemState.settings.scanFrequency * 1000;
      
      // Clear existing timer
      if (SystemState.nextScanTimer) {
        clearInterval(SystemState.nextScanTimer);
      }
      
      // Start countdown
      let secondsLeft = SystemState.settings.scanFrequency;
      updateNextScanDisplay(secondsLeft);
      
      SystemState.nextScanTimer = setInterval(() => {
        secondsLeft--;
        
        if (secondsLeft <= 0) {
          clearInterval(SystemState.nextScanTimer);
          performScan();
        } else {
          updateNextScanDisplay(secondsLeft);
        }
      }, 1000);
    }

    function updateNextScanDisplay(seconds) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      Elements.nextScan.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    function updateRunTime() {
      if (!SystemState.startTime) return;
      
      const now = Date.now();
      const diff = now - SystemState.startTime;
      
      const hours = Math.floor(diff / 3600000);
      const minutes = Math.floor((diff % 3600000) / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      
      Elements.runTime.textContent = 
        `${hours.toString().padStart(2, '0')}:` +
        `${minutes.toString().padStart(2, '0')}:` +
        `${seconds.toString().padStart(2, '0')}`;
    }

    function addLog(message) {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `<div class="log-entry">
        <span class="log-time">[${timestamp}]</span>
        <span class="log-message"> ${message}</span>
      </div>`;
      
      Elements.statusLogs.innerHTML = logEntry + Elements.statusLogs.innerHTML;
      
      // Keep only last 10 logs
      const logs = Elements.statusLogs.querySelectorAll('.log-entry');
      if (logs.length > 10) {
        logs[logs.length - 1].remove();
      }
      
      // Auto-scroll to top
      Elements.statusLogs.scrollTop = 0;
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    function initializeSystem() {
      // Load saved settings
      loadSettings();
      
      // Set up event listeners
      setupEventListeners();
      
      // Initialize UI
      Elements.systemIndicator.className = 'status-indicator status-neutral';
      Elements.lastScan.textContent = '--:--:--';
      Elements.nextScan.textContent = '--:--';
      Elements.runTime.textContent = '00:00:00';
      
      // Add initial log
      addLog('Pok√©mon Queue Detection System initialized');
      addLog('Cubone (Scanner) and Magikarp (Security) ready');
      addLog('Enter alert methods and press START SCAN');
    }

    function loadSettings() {
      const saved = JSON.parse(localStorage.getItem('poke_queue_settings') || '{}');
      
      if (saved.email) {
        Elements.emailInput.value = saved.email;
      }
      
      if (saved.webhook) {
        Elements.webhookInput.value = saved.webhook;
      }
      
      if (saved.frequency) {
        Elements.frequencySlider.value = saved.frequency;
        Elements.frequencyValue.textContent = saved.frequency;
        SystemState.settings.scanFrequency = saved.frequency;
      }
      
      if (saved.emailAlerts !== undefined) {
        Elements.emailToggle.checked = saved.emailAlerts;
        SystemState.settings.emailAlerts = saved.emailAlerts;
      }
      
      if (saved.webhookAlerts !== undefined) {
        Elements.webhookToggle.checked = saved.webhookAlerts;
        SystemState.settings.webhookAlerts = saved.webhookAlerts;
      }
    }

    function saveSettings() {
      const settings = {
        email: Elements.emailInput.value.trim(),
        webhook: Elements.webhookInput.value.trim(),
        frequency: SystemState.settings.scanFrequency,
        emailAlerts: SystemState.settings.emailAlerts,
        webhookAlerts: SystemState.settings.webhookAlerts
      };
      
      localStorage.setItem('poke_queue_settings', JSON.stringify(settings));
    }

    function setupEventListeners() {
      // Control buttons
      Elements.startBtn.addEventListener('click', startSystem);
      Elements.stopBtn.addEventListener('click', stopSystem);
      Elements.testBtn.addEventListener('click', () => AlertSystem.sendAlert('TEST_ALERT'));
      Elements.scanNowBtn.addEventListener('click', () => {
        if (SystemState.isScanning) {
          performScan();
        } else {
          alert('Please start the system first');
        }
      });
      
      // Settings controls
      Elements.frequencySlider.addEventListener('input', (e) => {
        const seconds = parseInt(e.target.value);
        Elements.frequencyValue.textContent = seconds;
        SystemState.settings.scanFrequency = seconds;
        saveSettings();
      });
      
      Elements.emailToggle.addEventListener('change', (e) => {
        SystemState.settings.emailAlerts = e.target.checked;
        saveSettings();
      });
      
      Elements.webhookToggle.addEventListener('change', (e) => {
        SystemState.settings.webhookAlerts = e.target.checked;
        saveSettings();
      });
      
      // Preset buttons
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const seconds = parseInt(btn.dataset.seconds);
          Elements.frequencySlider.value = seconds;
          Elements.frequencyValue.textContent = seconds;
          SystemState.settings.scanFrequency = seconds;
          saveSettings();
          
          if (SystemState.isScanning) {
            stopSystem();
            setTimeout(startSystem, 100);
          }
        });
      });
      
      // Save settings when inputs change
      Elements.emailInput.addEventListener('input', saveSettings);
      Elements.webhookInput.addEventListener('input', saveSettings);
    }

    function validateEmail(email) {
      const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return re.test(email);
    }

    // ============================================
    // START THE SYSTEM
    // ============================================

    document.addEventListener('DOMContentLoaded', initializeSystem);
  </script>
</body>
</html>
